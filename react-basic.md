# KURIKULUM DEVELOPER REACT EXPERT

## OVERVIEW

**Nama Program**: React Expert Developer Path  
**Durasi**: 6 bulan (24 minggu)  
**Level**: Basic hingga Expert  
**Metode Pembelajaran**: Teori dan Praktek (Project-based)

## TIMELINE PEMBELAJARAN

- **Level Basic** (Minggu 1-6): 6 minggu
- **Level Intermediate** (Minggu 7-14): 8 minggu 
- **Level Advanced** (Minggu 15-20): 6 minggu
- **Level Expert** (Minggu 21-24): 4 minggu

## DAFTAR MODUL

### LEVEL BASIC (Minggu 1-6)

#### MODUL 1: PENGENALAN WEB DEVELOPMENT (Minggu 1)
- **Durasi**: 1 minggu
- **Tujuan**: Memahami fondasi web development dan JavaScript modern yang diperlukan untuk React
- **Materi**:
  - HTML5 dan Semantic Elements
  - CSS3, Flexbox dan Grid
  - JavaScript Fundamentals dan ES6+
  - DOM Manipulation
  - Browser Developer Tools
- **Project**: Landing page sederhana dengan JavaScript interaktif

#### MODUL 2: PENGENALAN REACT (Minggu 2-3)
- **Durasi**: 2 minggu
- **Tujuan**: Memahami konsep dasar React dan cara kerjanya
- **Materi**:
  - Apa itu React dan Virtual DOM
  - Setting up React environment (Create React App)
  - JSX Syntax
  - Function Components vs Class Components
  - Props dan Component Composition
  - Event Handling di React
- **Project**: Konversi landing page dari Modul 1 ke React

#### MODUL 3: REACT FUNDAMENTALS (Minggu 4-6)
- **Durasi**: 3 minggu
- **Tujuan**: Menguasai konsep state, lifecycle, dan rendering di React
- **Materi**:
  - React Hooks: useState dan useEffect
  - Conditional Rendering
  - Lists dan Keys
  - Forms dan Controlled Components
  - Styling di React
  - Component Lifecycle
- **Project**: To-Do List Application

### LEVEL INTERMEDIATE (Minggu 7-14)

#### MODUL 4: REACT ECOSYSTEM & ROUTING (Minggu 7-8)
- **Durasi**: 2 minggu
- **Tujuan**: Memahami ekosistem React dan implementasi routing
- **Materi**:
  - React Router
  - Navigation dan URL Parameters
  - Nested Routes
  - Protected Routes
  - Code Splitting
  - Lazy Loading
- **Project**: Multi-page Application dengan React Router

#### MODUL 5: STATE MANAGEMENT (Minggu 9-11)
- **Durasi**: 3 minggu
- **Tujuan**: Menguasai state management di aplikasi React yang kompleks
- **Materi**:
  - Context API dan useContext
  - React Redux
  - Redux Toolkit
  - Immutability Patterns
  - Middleware dan Side Effects
  - Redux Thunk vs Redux Saga
- **Project**: E-Commerce App dengan state management kompleks

#### MODUL 6: DATA FETCHING & API INTEGRATION (Minggu 12-14)
- **Durasi**: 3 minggu
- **Tujuan**: Menguasai teknik fetching data dan integrasi API
- **Materi**:
  - Fetch API dan Axios
  - Custom Hooks untuk Data Fetching
  - React Query dan SWR
  - Loading States dan Error Handling
  - Caching dan Optimistic Updates
  - Authentication Flow
- **Project**: Dashboard App dengan integrasi API

### LEVEL ADVANCED (Minggu 15-20)

#### MODUL 7: ADVANCED HOOKS & PATTERNS (Minggu 15-16)
- **Durasi**: 2 minggu
- **Tujuan**: Memahami hooks lanjutan dan pattern design React
- **Materi**:
  - useCallback, useMemo, dan useRef
  - Custom Hooks Development
  - Higher-Order Components
  - Render Props Pattern
  - Compound Components
  - Control Props Pattern
- **Project**: Library of reusable React components

#### MODUL 8: PERFORMANCE OPTIMIZATION (Minggu 17-18)
- **Durasi**: 2 minggu
- **Tujuan**: Mengoptimalkan performa aplikasi React
- **Materi**:
  - React Profiler & Chrome DevTools
  - Code Splitting & Lazy Loading
  - React.memo dan PureComponent
  - Virtualization dengan React Window
  - Web Vitals Optimization
  - Bundle Analysis dan Optimization
- **Project**: Optimizing an existing React application

#### MODUL 9: TESTING & DEBUGGING (Minggu 19-20)
- **Durasi**: 2 minggu
- **Tujuan**: Menguasai teknik testing dan debugging di React
- **Materi**:
  - Jest dan React Testing Library
  - Component Testing
  - Integration Testing
  - Snapshot Testing
  - Mocking API Calls
  - Advanced Debugging Techniques
- **Project**: Test suite untuk aplikasi React

### LEVEL EXPERT (Minggu 21-24)

#### MODUL 10: SERVER-SIDE RENDERING & STATIC SITE GENERATION (Minggu 21-22)
- **Durasi**: 2 minggu
- **Tujuan**: Memahami SSR dan SSG dengan React
- **Materi**:
  - Next.js Fundamentals
  - SSR vs SSG vs ISR
  - Data Fetching in Next.js
  - API Routes
  - SEO Optimization
  - Deployment Strategies
- **Project**: Blog platform dengan Next.js

#### MODUL 11: ADVANCED STATE MANAGEMENT & ARCHITECTURE (Minggu 23)
- **Durasi**: 1 minggu
- **Tujuan**: Menguasai arsitektur state management tingkat lanjut
- **Materi**:
  - State Machines dengan XState
  - Zustand dan Jotai
  - Redux vs Context API (Tradeoffs)
  - Micro Frontends
  - Monorepo Architecture
  - Module Federation
- **Project**: Enterprise-level application architecture

#### MODUL 12: CAPSTONE PROJECT & ADVANCED TOPICS (Minggu 24)
- **Durasi**: 1 minggu
- **Tujuan**: Menggabungkan semua pembelajaran dalam proyek kompleks
- **Materi**:
  - React 18 Features
  - Concurrent Mode
  - React Server Components
  - Suspense for Data Fetching
  - Web Animations API integration
  - WebAssembly dengan React
- **Project**: Full-stack application dengan fitur modern React

---

## DETAIL MODUL

### MODUL 1: PENGENALAN WEB DEVELOPMENT

#### Topik 1.1: HTML5 dan Semantic Elements
**Durasi**: 1 hari  
**Materi**:
- Struktur dokumen HTML5
- Semantic elements: `<header>`, `<footer>`, `<section>`, `<article>`, `<nav>`, `<aside>`
- Atribut data- dan role
- Aksesibilitas dasar (ARIA)

**Hands-on Practice**:
- Membuat struktur halaman web yang semantik
- Mengimplementasikan form dengan validasi HTML5

#### Topik 1.2: CSS3, Flexbox dan Grid
**Durasi**: 1 hari  
**Materi**:
- CSS Selectors dan specificity
- Box model dan layout
- Flexbox untuk one-dimensional layout
- CSS Grid untuk two-dimensional layout
- Responsive design dengan media queries

**Hands-on Practice**:
- Membuat layout responsive dengan Flexbox
- Mengimplementasikan grid layout kompleks

#### Topik 1.3: JavaScript Fundamentals
**Durasi**: 2 hari  
**Materi**:
- Tipe data, variabel, dan scope
- Functions dan closures
- Objects dan arrays
- Prototype inheritance
- Error handling

**Hands-on Practice**:
- Mengimplementasikan algoritma dasar
- Membuat fungsi-fungsi utility

#### Topik 1.4: Modern JavaScript (ES6+)
**Durasi**: 2 hari  
**Materi**:
- Arrow functions
- Template literals
- Destructuring assignment
- Spread/rest operators
- Default parameters
- Classes
- Modules (import/export)
- Promises dan async/await

**Hands-on Practice**:
- Refactoring kode ES5 ke ES6+
- Implementasi asynchronous operations

**Project Modul 1**:  
Membuat landing page responsive dengan fitur:
- Navigasi sticky
- Hero section dengan animasi
- Gallery dengan grid layout
- Form validasi dengan JavaScript
- Dark/light mode toggle

### MODUL 2: PENGENALAN REACT

#### Topik 2.1: Pengenalan dan Setup
**Durasi**: 1 hari  
**Materi**:
- Apa itu React dan mengapa menggunakannya
- Virtual DOM dan diffing algorithm
- Single Page Application
- Setting up environment dengan Create React App
- React Developer Tools

**Hands-on Practice**:
- Membuat project pertama dengan Create React App
- Eksplorasi struktur project
- Menggunakan React Developer Tools

#### Topik 2.2: JSX dan Elements
**Durasi**: 1 hari  
**Materi**:
- Sintaks JSX
- Expressions di JSX
- Atribut di JSX
- Children elements
- Fragments
- Perbedaan JSX dengan HTML

**Hands-on Practice**:
- Menulis berbagai expressions di JSX
- Mengkonversi HTML ke JSX

#### Topik 2.3: Function dan Class Components
**Durasi**: 2 hari  
**Materi**:
- Function Components dasar
- Class Components dasar
- Perbedaan Function dan Class Components
- Props dan PropTypes
- Default Props
- Children prop

**Hands-on Practice**:
```jsx
// Function Component
function Greeting({ name = "Guest", role }) {
  return (
    <div className="greeting">
      <h2>Hello, {name}!</h2>
      {role && <p>Your role: {role}</p>}
    </div>
  );
}

#### Topik 7.2: Custom Hooks Development
**Durasi**: 1 hari  
**Materi**:
- Creating custom hooks
- Composing multiple hooks
- Rules of hooks
- Testing custom hooks
- Custom hooks best practices
- Reusable logic patterns

**Hands-on Practice**:
```jsx
// useLocalStorage hook
function useLocalStorage(key, initialValue) {
  // State to store our value
  const [storedValue, setStoredValue] = useState(() => {
    try {
      // Get from local storage by key
      const item = window.localStorage.getItem(key);
      // Parse stored json or if none return initialValue
      return item ? JSON.parse(item) : initialValue;
    } catch (error) {
      console.error(error);
      return initialValue;
    }
  });

  // Return a wrapped version of useState's setter function that
  // persists the new value to localStorage
  const setValue = (value) => {
    try {
      // Allow value to be a function
      const valueToStore =
        value instanceof Function ? value(storedValue) : value;
      // Save state
      setStoredValue(valueToStore);
      // Save to local storage
      window.localStorage.setItem(key, JSON.stringify(valueToStore));
    } catch (error) {
      console.error(error);
    }
  };

  return [storedValue, setValue];
}

// useMediaQuery hook
function useMediaQuery(query) {
  const [matches, setMatches] = useState(() => window.matchMedia(query).matches);

  useEffect(() => {
    const mediaQuery = window.matchMedia(query);
    const handler = (event) => setMatches(event.matches);
    
    // Set up event listener
    mediaQuery.addEventListener('change', handler);
    
    // Initial check
    setMatches(mediaQuery.matches);
    
    // Clean up
    return () => mediaQuery.removeEventListener('change', handler);
  }, [query]);

  return matches;
}

// useDebounce hook
function useDebounce(value, delay) {
  const [debouncedValue, setDebouncedValue] = useState(value);
  
  useEffect(() => {
    // Set debouncedValue to value after the specified delay
    const handler = setTimeout(() => {
      setDebouncedValue(value);
    }, delay);
    
    // Cancel the timeout if value changes or unmounts
    return () => {
      clearTimeout(handler);
    };
  }, [value, delay]);
  
  return debouncedValue;
}

// Using the custom hooks
function ThemeToggler() {
  // Use our custom localStorage hook
  const [theme, setTheme] = useLocalStorage('theme', 'light');
  
  // Use our custom media query hook
  const prefersDark = useMediaQuery('(prefers-color-scheme: dark)');
  
  useEffect(() => {
    // Set theme based on user's system preference on initial load
    if (prefersDark && theme === 'light') {
      setTheme('dark');
    }
  }, [prefersDark, setTheme, theme]);
  
  const toggleTheme = () => {
    setTheme(theme === 'light' ? 'dark' : 'light');
  };
  
  return (
    <button onClick={toggleTheme}>
      Current theme: {theme}
    </button>
  );
}

function SearchComponent() {
  const [searchTerm, setSearchTerm] = useState('');
  // Use our debounce hook to delay API calls
  const debouncedSearchTerm = useDebounce(searchTerm, 500);
  const [results, setResults] = useState([]);
  const [loading, setLoading] = useState(false);
  
  useEffect(() => {
    if (debouncedSearchTerm) {
      setLoading(true);
      // Make API call with debounced value
      fetchSearchResults(debouncedSearchTerm)
        .then(data => {
          setResults(data);
          setLoading(false);
        });
    } else {
      setResults([]);
    }
  }, [debouncedSearchTerm]);
  
  return (
    <div>
      <input
        value={searchTerm}
        onChange={(e) => setSearchTerm(e.target.value)}
        placeholder="Search..."
      />
      {loading && <p>Loading...</p>}
      <ul>
        {results.map(result => (
          <li key={result.id}>{result.name}</li>
        ))}
      </ul>
    </div>
  );
}
```

#### Topik 7.3: Advanced Component Patterns
**Durasi**: 2 hari  
**Materi**:
- Higher-Order Components (HOC)
- Render Props
- Compound Components
- Controlled vs Uncontrolled Components
- State Initializers
- Prop Collections and Getters

**Hands-on Practice**:
```jsx
// Higher-Order Component
function withLogger(Component) {
  const displayName = Component.displayName || Component.name || 'Component';
  
  function WithLogger(props) {
    useEffect(() => {
      console.log(`${displayName} mounted`);
      return () => {
        console.log(`${displayName} unmounted`);
      };
    }, []);
    
    console.log(`${displayName} rendered with props:`, props);
    
    return <Component {...props} />;
  }
  
  WithLogger.displayName = `withLogger(${displayName})`;
  
  return WithLogger;
}

// Usage of HOC
const EnhancedButton = withLogger(Button);

// Render Props pattern
function Toggle({ children }) {
  const [on, setOn] = useState(false);
  
  const toggle = () => setOn(!on);
  
  return children({
    on,
    toggle
  });
}

// Usage of Render Props
function App() {
  return (
    <Toggle>
      {({ on, toggle }) => (
        <div>
          <button onClick={toggle}>
            {on ? 'Turn off' : 'Turn on'}
          </button>
          <div>{on ? 'The switch is on' : 'The switch is off'}</div>
        </div>
      )}
    </Toggle>
  );
}

// Compound Components pattern
const TabContext = createContext();

function Tabs({ children, defaultIndex = 0 }) {
  const [activeIndex, setActiveIndex] = useState(defaultIndex);
  
  const value = {
    activeIndex,
    setActiveIndex
  };
  
  return (
    <TabContext.Provider value={value}>
      <div className="tabs">{children}</div>
    </TabContext.Provider>
  );
}

function TabList({ children }) {
  return <div className="tab-list">{children}</div>;
}

function Tab({ children, index }) {
  const { activeIndex, setActiveIndex } = useContext(TabContext);
  
  return (
    <button
      className={`tab ${activeIndex === index ? 'active' : ''}`}
      onClick={() => setActiveIndex(index)}
    >
      {children}
    </button>
  );
}

function TabPanels({ children }) {
  return <div className="tab-panels">{children}</div>;
}

function TabPanel({ children, index }) {
  const { activeIndex } = useContext(TabContext);
  
  return activeIndex === index ? (
    <div className="tab-panel">{children}</div>
  ) : null;
}

// Attach components as properties
Tabs.TabList = TabList;
Tabs.Tab = Tab;
Tabs.TabPanels = TabPanels;
Tabs.TabPanel = TabPanel;

// Usage of Compound Components
function App() {
  return (
    <Tabs defaultIndex={1}>
      <Tabs.TabList>
        <Tabs.Tab index={0}>Tab 1</Tabs.Tab>
        <Tabs.Tab index={1}>Tab 2</Tabs.Tab>
        <Tabs.Tab index={2}>Tab 3</Tabs.Tab>
      </Tabs.TabList>
      
      <Tabs.TabPanels>
        <Tabs.TabPanel index={0}>
          <h2>Panel 1</h2>
          <p>Content for Panel 1</p>
        </Tabs.TabPanel>
        <Tabs.TabPanel index={1}>
          <h2>Panel 2</h2>
          <p>Content for Panel 2</p>
        </Tabs.TabPanel>
        <Tabs.TabPanel index={2}>
          <h2>Panel 3</h2>
          <p>Content for Panel 3</p>
        </Tabs.TabPanel>
      </Tabs.TabPanels>
    </Tabs>
  );
}

// Prop Getters pattern
function useToggle() {
  const [on, setOn] = useState(false);
  
  const toggle = () => setOn(!on);
  
  // Function to get props for the toggle button
  const getTogglerProps = ({ onClick, ...props } = {}) => ({
    'aria-pressed': on,
    onClick: (event) => {
      // Call provided onClick if it exists
      onClick?.(event);
      // Call our toggle function
      toggle();
    },
    ...props
  });
  
  return {
    on,
    toggle,
    getTogglerProps
  };
}

// Usage of Prop Getters
function App() {
  const { on, getTogglerProps } = useToggle();
  
  return (
    <div>
      <button
        {...getTogglerProps({
          'aria-label': 'Toggle feature',
          onClick: () => console.log('Button clicked'),
          className: on ? 'active' : ''
        })}
      >
        {on ? 'ON' : 'OFF'}
      </button>
      <div>{on ? 'Feature enabled' : 'Feature disabled'}</div>
    </div>
  );
}
```

#### Topik 7.4: State Management Patterns
**Durasi**: 2 hari  
**Materi**:
- Context + useReducer pattern
- State machines
- Finite state management
- Custom store implementations
- Observer pattern
- Atomic state management

**Hands-on Practice**:
```jsx
// Context + useReducer pattern
const TodoContext = createContext();

const initialState = {
  todos: [],
  filter: 'all',
  loading: false,
  error: null
};

function todoReducer(state, action) {
  switch (action.type) {
    case 'FETCH_START':
      return { ...state, loading: true, error: null };
    case 'FETCH_SUCCESS':
      return { ...state, loading: false, todos: action.payload };
    case 'FETCH_ERROR':
      return { ...state, loading: false, error: action.payload };
    case 'ADD_TODO':
      return { ...state, todos: [...state.todos, action.payload] };
    case 'TOGGLE_TODO':
      return {
        ...state,
        todos: state.todos.map(todo =>
          todo.id === action.payload
            ? { ...todo, completed: !todo.completed }
            : todo
        )
      };
    case 'DELETE_TODO':
      return {
        ...state,
        todos: state.todos.filter(todo => todo.id !== action.payload)
      };
    case 'SET_FILTER':
      return { ...state, filter: action.payload };
    default:
      return state;
  }
}

function TodoProvider({ children }) {
  const [state, dispatch] = useReducer(todoReducer, initialState);
  
  // Memoize the context value to prevent unnecessary re-renders
  const value = useMemo(() => [state, dispatch], [state]);
  
  return (
    <TodoContext.Provider value={value}>
      {children}
    </TodoContext.Provider>
  );
}

// Custom hook to use the todo context
function useTodo() {
  const context = useContext(TodoContext);
  if (!context) {
    throw new Error('useTodo must be used within a TodoProvider');
  }
  return context;
}

// Simple state machine implementation
function createMachine(initialState, transitions) {
  return {
    value: initialState,
    transition(currentState, event) {
      const nextState = transitions[currentState]?.[event];
      return nextState !== undefined ? nextState : currentState;
    }
  };
}

function useMachine(machine) {
  const [state, setState] = useState(machine.value);
  
  const send = useCallback((event) => {
    setState(s => machine.transition(s, event));
  }, [machine]);
  
  return [state, send];
}

// Usage of state machine
const trafficLightMachine = createMachine('red', {
  red: { NEXT: 'green' },
  green: { NEXT: 'yellow' },
  yellow: { NEXT: 'red' }
});

function TrafficLight() {
  const [state, send] = useMachine(trafficLightMachine);
  
  return (
    <div className="traffic-light">
      <div className={`light red ${state === 'red' ? 'active' : ''}`} />
      <div className={`light yellow ${state === 'yellow' ? 'active' : ''}`} />
      <div className={`light green ${state === 'green' ? 'active' : ''}`} />
      
      <button onClick={() => send('NEXT')}>
        Change to next light
      </button>
    </div>
  );
}

// Custom observable store implementation
function createStore(initialState) {
  let state = initialState;
  const listeners = new Set();
  
  const getState = () => state;
  
  const setState = (newState) => {
    state = typeof newState === 'function' ? newState(state) : newState;
    listeners.forEach(listener => listener(state));
  };
  
  const subscribe = (listener) => {
    listeners.add(listener);
    return () => listeners.delete(listener);
  };
  
  return { getState, setState, subscribe };
}

// React hook to use the custom store
function useStore(store) {
  const [state, setState] = useState(store.getState());
  
  useEffect(() => {
    const unsubscribe = store.subscribe(setState);
    return unsubscribe;
  }, [store]);
  
  return [state, store.setState];
}

// Usage of custom store
const counterStore = createStore({ count: 0 });

function Counter() {
  const [state, setState] = useStore(counterStore);
  
  const increment = () => {
    setState(s => ({ count: s.count + 1 }));
  };
  
  const decrement = () => {
    setState(s => ({ count: s.count - 1 }));
  };
  
  return (
    <div>
      <p>Count: {state.count}</p>
      <button onClick={decrement}>-</button>
      <button onClick={increment}>+</button>
    </div>
  );
}
```

**Project Modul 7**:  
Membuat Library of reusable React components:
- Component library dengan storybook
- Compound components untuk kompleksitas UI
- Hook libraries untuk reusable logic
- Custom form components dengan validation
- Themeable components dengan styled-components
- Accessible component design
- Component API dokumentasi

### MODUL 8: PERFORMANCE OPTIMIZATION

#### Topik 8.1: Measuring Performance
**Durasi**: 1 hari  
**Materi**:
- React DevTools Profiler
- Chrome DevTools Performance tab
- Lighthouse audit
- Performance metrics (FCP, LCP, TTI, CLS)
- Performance budgets
- Identifying bottlenecks

**Hands-on Practice**:
```jsx
// Example of using React Profiler programmatically
import { Profiler } from 'react';

function onRenderCallback(
  id, // the "id" prop of the Profiler tree that just committed
  phase, // either "mount" (if the tree just mounted) or "update" (if it re-rendered)
  actualDuration, // time spent rendering the committed update
  baseDuration, // estimated time to render the entire subtree without memoization
  startTime, // when React began rendering this update
  commitTime, // when React committed this update
  interactions // the Set of interactions belonging to this update
) {
  // Log performance data
  console.log({
    id,
    phase,
    actualDuration,
    baseDuration,
    startTime,
    commitTime
  });
}

function App() {
  return (
    <Profiler id="main-app" onRender={onRenderCallback}>
      <MainComponent />
    </Profiler>
  );
}

// Custom hook to track component renders
function useRenderCount() {
  const count = useRef(1);
  
  useEffect(() => {
    count.current += 1;
  });
  
  return count.current;
}

function ExpensiveComponent({ data }) {
  const renderCount = useRenderCount();
  
  console.log(`ExpensiveComponent rendered ${renderCount} times`);
  
  // Simulate expensive calculation
  const processedData = useMemo(() => {
    console.time('processData');
    const result = expensiveCalculation(data);
    console.timeEnd('processData');
    return result;
  }, [data]);
  
  return (
    <div>
      <p>Render count: {renderCount}</p>
      <ul>
        {processedData.map(item => (
          <li key={item.id}>{item.name}</li>
        ))}
      </ul>
    </div>
  );
}
```

#### Topik 8.2: Component Optimization
**Durasi**: 1 hari  
**Materi**:
- React.memo
- shouldComponentUpdate
- PureComponent
- Using keys properly
- Avoiding props spreading
- Avoiding anonymous functions
- Avoiding inline objects

**Hands-on Practice**:
```jsx
// Before optimization
function ItemList({ items, onItemClick }) {
  console.log('ItemList rendering');
  
  return (
    <ul>
      {items.map(item => (
        <li 
          key={item.id}
          onClick={() => onItemClick(item.id)}
          style={{ margin: '10px', padding: '10px' }}
        >
          {item.name}
        </li>
      ))}
    </ul>
  );
}

// After optimization with React.memo
const MemoizedItem = React.memo(function Item({ item, onClick }) {
  console.log(`Item ${item.id} rendering`);
  
  // Extract inline function to component level
  const handleClick = () => {
    onClick(item.id);
  };
  
  // Extract inline styles
  const itemStyle = { margin: '10px', padding: '10px' };
  
  return (
    <li 
      onClick={handleClick}
      style={itemStyle}
    >
      {item.name}
    </li>
  );
});

const MemoizedItemList = React.memo(function ItemList({ items, onItemClick }) {
  console.log('ItemList rendering');
  
  return (
    <ul>
      {items.map(item => (
        <MemoizedItem 
          key={item.id}
          item={item}
          onClick={onItemClick}
        />
      ))}
    </ul>
  );
});

// Using useCallback to prevent function recreation
function ParentComponent() {
  const [items, setItems] = useState([/* items data */]);
  
  // Memoize the click handler
  const handleItemClick = useCallback((id) => {
    console.log(`Item ${id} clicked`);
    // Other logic...
  }, []);
  
  return (
    <MemoizedItemList 
      items={items}
      onItemClick={handleItemClick}
    />
  );
}

// Class component optimization with PureComponent
class PureList extends React.PureComponent {
  render() {
    const { items, onItemClick } = this.props;
    
    return (
      <ul>
        {items.map(item => (
          <li 
            key={item.id}
            onClick={() => onItemClick(item.id)}
          >
            {item.name}
          </li>
        ))}
      </ul>
    );
  }
}

// Manual shouldComponentUpdate implementation
class ManualOptimizedList extends React.Component {
  shouldComponentUpdate(nextProps) {
    // Only re-render if items array reference changed
    return this.props.items !== nextProps.items;
  }
  
  render() {
    const { items, onItemClick } = this.props;
    
    return (
      <ul>
        {items.map(item => (
          <li 
            key={item.id}
            onClick={() => onItemClick(item.id)}
          >
            {item.name}
          </li>
        ))}
      </ul>
    );
  }
}
```

#### Topik 8.3: Code Splitting & Lazy Loading
**Durasi**: 1 hari  
**Materi**:
- Dynamic imports
- React.lazy
- Suspense
- Route-based code splitting
- Component-based code splitting
- Preloading strategies
- Loading states

**Hands-on Practice**:
```jsx
import React, { Suspense, lazy } from 'react';
import { BrowserRouter as Router, Route, Switch } from 'react-router-dom';
import ErrorBoundary from './ErrorBoundary';

// Regular import
import Home from './pages/Home';
import Loading from './components/Loading';

// Lazy imports
const About = lazy(() => import('./pages/About'));
const Dashboard = lazy(() => import('./pages/Dashboard'));
const Profile = lazy(() => import('./pages/Profile'));

// Prefetch component when mouse hovers over link
function prefetchAbout() {
  import('./pages/About');
}

function App() {
  return (
    <Router>
      <nav>
        <a href="/">Home</a>
        <a href="/about" onMouseEnter={prefetchAbout}>About</a>
        <a href="/dashboard">Dashboard</a>
        <a href="/profile">Profile</a>
      </nav>
      
      <ErrorBoundary fallback={<p>Something went wrong</p>}>
        <Suspense fallback={<Loading />}>
          <Switch>
            <Route exact path="/" component={Home} />
            <Route path="/about" component={About} />
            <Route path="/dashboard" component={Dashboard} />
            <Route path="/profile" component={Profile} />
          </Switch>
        </Suspense>
      </ErrorBoundary>
    </Router>
  );
}

// Component-level code splitting
function MyImageGallery() {
  const [showGallery, setShowGallery] = useState(false);
  
  // Lazy load the heavy gallery component
  const Gallery = lazy(() => import('./components/Gallery'));
  
  return (
    <div>
      <button onClick={() => setShowGallery(true)}>
        Show Gallery
      </button>
      
      {showGallery && (
        <Suspense fallback={<p>Loading gallery...</p>}>
          <Gallery />
        </Suspense>
      )}
    </div>
  );
}
```

#### Topik 8.4: Virtualization & Windowing
**Durasi**: 1 hari  
**Materi**:
- Virtual scrolling concepts
- react-window
- react-virtualized
- IntersectionObserver
- Lazy loading images
- Infinite scroll implementation
- Load-on-demand strategies

**Hands-on Practice**:
```jsx
import { FixedSizeList } from 'react-window';
import { useState, useRef, useCallback } from 'react';

// Basic react-window implementation
function VirtualizedList({ items }) {
  // Row renderer
  const Row = ({ index, style }) => (
    <div style={style} className="list-item">
      {items[index].name}
    </div>
  );
  
  return (
    <FixedSizeList
      height={400}
      width="100%"
      itemCount={items.length}
      itemSize={50}
    >
      {Row}
    </FixedSizeList>
  );
}

// Infinite scroll with IntersectionObserver
function InfiniteScrollList() {
  const [items, setItems] = useState([]);
  const [page, setPage] = useState(1);
  const [loading, setLoading] = useState(false);
  const [hasMore, setHasMore] = useState(true);
  
  const observer = useRef();
  
  const lastItemRef = useCallback(node => {
    if (loading) return;
    
    if (observer.current) {
      observer.current.disconnect();
    }
    
    observer.current = new IntersectionObserver(entries => {
      if (entries[0].isIntersecting && hasMore) {
        loadMoreItems();
      }
    });
    
    if (node) {
      observer.current.observe(node);
    }
  }, [loading, hasMore]);
  
  const loadMoreItems = async () => {
    setLoading(true);
    try {
      const newItems = await fetchItems(page);
      if (newItems.length === 0) {
        setHasMore(false);
      } else {
        setItems(prev => [...prev, ...newItems]);
        setPage(prev => prev + 1);
      }
    } catch (error) {
      console.error('Error loading more items:', error);
    } finally {
      setLoading(false);
    }
  };
  
  return (
    <div className="infinite-scroll-list">
      {items.map((item, index) => (
        <div
          key={item.id}
          ref={index === items.length - 1 ? lastItemRef : null}
          className="list-item"
        >
          {item.name}
        </div>
      ))}
      {loading && <div className="loading">Loading...</div>}
      {!hasMore && <div>No more items</div>}
    </div>
  );
}

// Lazy loading images with IntersectionObserver
function LazyImage({ src, alt, placeholder }) {
  const [isLoaded, setIsLoaded] = useState(false);
  const imgRef = useRef();
  
  useEffect(() => {
    const observer = new IntersectionObserver(entries => {
      entries.forEach(entry => {
        if (entry.isIntersecting) {
          const img = entry.target;
          const realSrc = img.dataset.src;
          img.src = realSrc;
          img.addEventListener('load', () => {
            setIsLoaded(true);
            observer.unobserve(img);
          });
        }
      });
    });
    
    if (imgRef.current) {
      observer.observe(imgRef.current);
    }
    
    return () => {
      if (imgRef.current) {
        observer.unobserve(imgRef.current);
      }
    };
  }, []);
  
  return (
    <div className={`lazy-image ${isLoaded ? 'loaded' : ''}`}>
      <img
        ref={imgRef}
        data-src={src}
        src={placeholder}
        alt={alt}
      />
      {!isLoaded && <div className="placeholder" />}
    </div>
  );
}
```

#### Topik 8.5: Bundle Optimization
**Durasi**: 1 hari  
**Materi**:
- Webpack configuration
- Tree shaking
- Bundle analyzer
- Reducing bundle size
- Code splitting strategies
- Dynamic imports
- Compression techniques

**Hands-on Practice**:
```javascript
// webpack.config.js example
const path = require('path');
const BundleAnalyzerPlugin = require('webpack-bundle-analyzer').BundleAnalyzerPlugin;
const CompressionPlugin = require('compression-webpack-plugin');
const TerserPlugin = require('terser-webpack-plugin');

module.exports = {
  entry: './src/index.js',
  output: {
    path: path.resolve(__dirname, 'dist'),
    filename: '[name].[contenthash].js',
    chunkFilename: '[name].[contenthash].chunk.js',
  },
  optimization: {
    minimizer: [new TerserPlugin()],
    splitChunks: {
      chunks: 'all',
      cacheGroups: {
        vendors: {
          test: /[\\/]node_modules[\\/]/,
          name: 'vendors',
          chunks: 'all',
          priority: -10,
        },
        common: {
          name: 'common',
          minChunks: 2,
          priority: -20,
          reuseExistingChunk: true,
        }
      }
    },
  },
  plugins: [
    new BundleAnalyzerPlugin({
      analyzerMode: 'static',
      reportFilename: 'bundle-report.html',
    }),
    new CompressionPlugin({
      algorithm: 'gzip',
      test: /\.(js|css|html|svg)$/,
      threshold: 10240, // Only compress files > 10kb
      minRatio: 0.8,
    }),
  ],
};

// React code examples for optimizing imports
// Bad - imports the entire lodash library
import _ from 'lodash';

// Good - only imports the specific methods needed
import map from 'lodash/map';
import filter from 'lodash/filter';

// Using dynamic imports for code splitting
const importExpensiveModule = () => import('./ExpensiveModule');

function MyComponent() {
  const [module, setModule] = useState(null);
  
  const loadModule = async () => {
    try {
      const { default: ExpensiveModule } = await importExpensiveModule();
      setModule(ExpensiveModule);
    } catch (error) {
      console.error('Failed to load module:', error);
    }
  };
  
  return (
    <div>
      <button onClick={loadModule}>Load Module</button>
      {module && <module.Component />}
    </div>
  );
}
```

**Project Modul 8**:  
Optimizing an existing React application:
- Performance audit with Lighthouse
- Memoization dan component optimizations
- Implementing lazy loading dan code splitting
- Virtual scroll

// Class Component
class Counter extends React.Component {
  constructor(props) {
    super(props);
    this.state = { count: 0 };
    this.increment = this.increment.bind(this);
  }
  
  increment() {
    this.setState({ count: this.state.count + 1 });
  }
  
  render() {
    return (
      <div>
        <p>Count: {this.state.count}</p>
        <button onClick={this.increment}>Increment</button>
      </div>
    );
  }
}
```

#### Topik 2.4: Event Handling
**Durasi**: 1 hari  
**Materi**:
- Event handling di React
- SyntheticEvent
- Binding event handlers
- Event pooling
- Passing arguments ke event handlers

**Hands-on Practice**:
```jsx
function ToggleButton() {
  const [isOn, setIsOn] = React.useState(false);
  
  // Event handler dengan parameter
  const handleClick = (event, newState) => {
    console.log(event.type); // "click"
    setIsOn(newState);
  };
  
  return (
    <button 
      className={isOn ? "btn-on" : "btn-off"}
      onClick={(e) => handleClick(e, !isOn)}
    >
      {isOn ? "ON" : "OFF"}
    </button>
  );
}
```

#### Topik 2.5: Component Composition
**Durasi**: 1 hari  
**Materi**:
- Containment
- Specialization
- Props.children
- Composition vs Inheritance
- Extracting Components

**Hands-on Practice**:
```jsx
// Component composition
function Card({ title, children }) {
  return (
    <div className="card">
      <div className="card-header">{title}</div>
      <div className="card-body">{children}</div>
    </div>
  );
}

function App() {
  return (
    <Card title="Welcome">
      <p>This is a reusable card component.</p>
      <button>Click me</button>
    </Card>
  );
}
```

**Project Modul 2**:  
Konversi landing page dari Modul 1 ke React:
- Memecah UI menjadi component hierarchy
- Mengimplementasikan navigation sebagai component
- Membuat reusable UI components (Button, Card, etc.)
- Menerapkan props untuk konfigurasi components
- Menerapkan event handling untuk interaksi

### MODUL 3: REACT FUNDAMENTALS

#### Topik 3.1: State dan Hooks Dasar
**Durasi**: 2 hari  
**Materi**:
- State concept
- useState hook
- Multiple state variables
- State updates
- State lifting
- Lazy initial state

**Hands-on Practice**:
```jsx
function Counter() {
  // Basic state
  const [count, setCount] = useState(0);
  
  // Object state
  const [user, setUser] = useState({
    name: 'Guest',
    isLoggedIn: false
  });
  
  // Update object state properly
  const login = () => {
    setUser(prevUser => ({
      ...prevUser,
      name: 'John',
      isLoggedIn: true
    }));
  };
  
  return (
    <div>
      <p>Count: {count}</p>
      <button onClick={() => setCount(count + 1)}>Increment</button>
      <button onClick={() => setCount(0)}>Reset</button>
      
      <hr />
      
      <p>
        {user.isLoggedIn ? `Welcome, ${user.name}!` : 'Please log in'}
      </p>
      <button onClick={login} disabled={user.isLoggedIn}>
        Log in
      </button>
    </div>
  );
}
```

#### Topik 3.2: Effects dan Lifecycle
**Durasi**: 2 hari  
**Materi**:
- useEffect hook
- Dependency array
- Cleanup function
- Component lifecycle dengan hooks
- Common useEffect patterns
- API calls dengan useEffect

**Hands-on Practice**:
```jsx
function UserProfile({ userId }) {
  const [profile, setProfile] = useState(null);
  const [loading, setLoading] = useState(true);
  const [error, setError] = useState(null);
  
  useEffect(() => {
    // Reset state when userId changes
    setLoading(true);
    setError(null);
    
    let isMounted = true;
    
    async function fetchProfile() {
      try {
        const response = await fetch(`/api/users/${userId}`);
        if (!response.ok) throw new Error('Failed to fetch');
        
        const data = await response.json();
        
        // Only update state if component is still mounted
        if (isMounted) {
          setProfile(data);
          setLoading(false);
        }
      } catch (err) {
        if (isMounted) {
          setError(err.message);
          setLoading(false);
        }
      }
    }
    
    fetchProfile();
    
    // Cleanup function
    return () => {
      isMounted = false;
    };
  }, [userId]); // Re-run when userId changes
  
  if (loading) return <p>Loading...</p>;
  if (error) return <p>Error: {error}</p>;
  if (!profile) return null;
  
  return (
    <div className="profile">
      <h2>{profile.name}</h2>
      <p>Email: {profile.email}</p>
    </div>
  );
}
```

#### Topik 3.3: Conditional Rendering
**Durasi**: 1 hari  
**Materi**:
- If statements
- Inline conditions with && operator
- Conditional (ternary) operator
- Preventing component rendering
- Switch statement patterns

**Hands-on Practice**:
```jsx
function StatusMessage({ status }) {
  // Pattern 1: If statement
  if (status === 'loading') {
    return <Spinner />;
  }
  
  // Pattern 2: Immediate return for error
  if (status === 'error') {
    return <ErrorMessage />;
  }
  
  // Pattern 3: Ternary operator
  return (
    <div>
      {status === 'success' 
        ? <SuccessMessage /> 
        : <p>Unknown status: {status}</p>}
      
      {/* Pattern 4: && operator */}
      {status === 'warning' && <WarningBanner />}
    </div>
  );
}
```

#### Topik 3.4: Lists dan Keys
**Durasi**: 1 hari  
**Materi**:
- Rendering multiple components
- Keys dan pentingnya
- Extracting components dengan keys
- Keys harus unik di antara siblings
- Best practices untuk keys

**Hands-on Practice**:
```jsx
function TodoList({ todos, onToggle, onDelete }) {
  return (
    <ul className="todo-list">
      {todos.map(todo => (
        <TodoItem
          key={todo.id}
          todo={todo}
          onToggle={onToggle}
          onDelete={onDelete}
        />
      ))}
    </ul>
  );
}

function TodoItem({ todo, onToggle, onDelete }) {
  return (
    <li className={todo.completed ? 'completed' : ''}>
      <input
        type="checkbox"
        checked={todo.completed}
        onChange={() => onToggle(todo.id)}
      />
      <span>{todo.text}</span>
      <button onClick={() => onDelete(todo.id)}>Delete</button>
    </li>
  );
}
```

#### Topik 3.5: Forms dan Controlled Components
**Durasi**: 2 hari  
**Materi**:
- Controlled components
- Handling multiple inputs
- Uncontrolled components
- Form validation
- React Hook Form

**Hands-on Practice**:
```jsx
function ContactForm() {
  const [formData, setFormData] = useState({
    name: '',
    email: '',
    message: ''
  });
  const [errors, setErrors] = useState({});
  
  const handleChange = (e) => {
    const { name, value } = e.target;
    setFormData(prev => ({
      ...prev,
      [name]: value
    }));
    
    // Clear error when user types
    if (errors[name]) {
      setErrors(prev => ({
        ...prev,
        [name]: null
      }));
    }
  };
  
  const validate = () => {
    const newErrors = {};
    
    if (!formData.name.trim()) {
      newErrors.name = 'Name is required';
    }
    
    if (!formData.email.trim()) {
      newErrors.email = 'Email is required';
    } else if (!/\S+@\S+\.\S+/.test(formData.email)) {
      newErrors.email = 'Email is invalid';
    }
    
    if (!formData.message.trim()) {
      newErrors.message = 'Message is required';
    }
    
    setErrors(newErrors);
    return Object.keys(newErrors).length === 0;
  };
  
  const handleSubmit = (e) => {
    e.preventDefault();
    
    if (validate()) {
      // Submit form data
      console.log('Form submitted:', formData);
      // Reset form
      setFormData({ name: '', email: '', message: '' });
    }
  };
  
  return (
    <form onSubmit={handleSubmit} className="contact-form">
      <div className="form-group">
        <label htmlFor="name">Name</label>
        <input
          type="text"
          id="name"
          name="name"
          value={formData.name}
          onChange={handleChange}
          className={errors.name ? 'error' : ''}
        />
        {errors.name && <p className="error-text">{errors.name}</p>}
      </div>
      
      <div className="form-group">
        <label htmlFor="email">Email</label>
        <input
          type="email"
          id="email"
          name="email"
          value={formData.email}
          onChange={handleChange}
          className={errors.email ? 'error' : ''}
        />
        {errors.email && <p className="error-text">{errors.email}</p>}
      </div>
      
      <div className="form-group">
        <label htmlFor="message">Message</label>
        <textarea
          id="message"
          name="message"
          value={formData.message}
          onChange={handleChange}
          className={errors.message ? 'error' : ''}
        />
        {errors.message && <p className="error-text">{errors.message}</p>}
      </div>
      
      <button type="submit" className="submit-btn">Send Message</button>
    </form>
  );
}
```

#### Topik 3.6: Styling di React
**Durasi**: 1 hari  
**Materi**:
- Inline styles
- CSS classes
- CSS Modules
- Styled Components
- CSS-in-JS libraries
- Tailwind CSS dengan React

**Hands-on Practice**:
```jsx
// CSS Modules example
import styles from './Button.module.css';

function Button({ variant = 'primary', children, ...props }) {
  return (
    <button
      className={`${styles.button} ${styles[variant]}`}
      {...props}
    >
      {children}
    </button>
  );
}

// Styled Components example
import styled from 'styled-components';

const StyledButton = styled.button`
  padding: 8px 16px;
  border-radius: 4px;
  font-weight: 600;
  cursor: pointer;
  
  ${props => props.variant === 'primary' && `
    background-color: #0070f3;
    color: white;
    border: none;
  `}
  
  ${props => props.variant === 'outline' && `
    background-color: transparent;
    color: #0070f3;
    border: 1px solid #0070f3;
  `}
`;

function Button({ variant = 'primary', children, ...props }) {
  return (
    <StyledButton variant={variant} {...props}>
      {children}
    </StyledButton>
  );
}
```

**Project Modul 3**:  
Membuat To-Do List Application:
- Fitur CRUD (Create, Read, Update, Delete)
- Form validasi untuk input task
- Filtering dan sorting tasks
- Persistent storage dengan localStorage
- Responsive design dengan multiple layout options
- Drag and drop untuk reordering tasks

### MODUL 4: REACT ECOSYSTEM & ROUTING

#### Topik 4.1: Introduction to React Router
**Durasi**: 1 hari  
**Materi**:
- React Router concepts
- BrowserRouter vs HashRouter
- Basic routing dengan Route
- Navigation dengan Link dan NavLink
- History API integration

**Hands-on Practice**:
```jsx
import { BrowserRouter, Routes, Route, Link, NavLink } from 'react-router-dom';

function App() {
  return (
    <BrowserRouter>
      <nav>
        <NavLink to="/" end className={({ isActive }) => 
          isActive ? 'active-link' : 'link'
        }>
          Home
        </NavLink>
        <NavLink to="/about" className={({ isActive }) => 
          isActive ? 'active-link' : 'link'
        }>
          About
        </NavLink>
        <NavLink to="/contact" className={({ isActive }) => 
          isActive ? 'active-link' : 'link'
        }>
          Contact
        </NavLink>
      </nav>
      
      <Routes>
        <Route path="/" element={<Home />} />
        <Route path="/about" element={<About />} />
        <Route path="/contact" element={<Contact />} />
        <Route path="*" element={<NotFound />} />
      </Routes>
    </BrowserRouter>
  );
}
```

#### Topik 4.2: Advanced Routing
**Durasi**: 2 hari  
**Materi**:
- URL parameters
- Query parameters
- Nested routes
- Index routes
- Layout routes
- Outlet component

**Hands-on Practice**:
```jsx
function App() {
  return (
    <BrowserRouter>
      <Routes>
        <Route path="/" element={<MainLayout />}>
          <Route index element={<Home />} />
          <Route path="about" element={<About />} />
          <Route path="products" element={<ProductsLayout />}>
            <Route index element={<ProductsList />} />
            <Route path=":productId" element={<ProductDetail />} />
          </Route>
          <Route path="contact" element={<Contact />} />
          <Route path="*" element={<NotFound />} />
        </Route>
      </Routes>
    </BrowserRouter>
  );
}

function MainLayout() {
  return (
    <div className="main-layout">
      <header>
        <nav>
          <NavLink to="/">Home</NavLink>
          <NavLink to="/about">About</NavLink>
          <NavLink to="/products">Products</NavLink>
          <NavLink to="/contact">Contact</NavLink>
        </nav>
      </header>
      
      <main>
        <Outlet /> {/* Child routes render here */}
      </main>
      
      <footer>Â© 2025 My Company</footer>
    </div>
  );
}

function ProductsLayout() {
  return (
    <div className="products-layout">
      <h1>Products</h1>
      <Outlet /> {/* Nested product routes render here */}
    </div>
  );
}

function ProductDetail() {
  const { productId } = useParams();
  const [product, setProduct] = useState(null);
  const [loading, setLoading] = useState(true);
  
  useEffect(() => {
    // Fetch product data based on productId
    fetchProduct(productId).then(data => {
      setProduct(data);
      setLoading(false);
    });
  }, [productId]);
  
  if (loading) return <p>Loading...</p>;
  if (!product) return <p>Product not found</p>;
  
  return (
    <div className="product-detail">
      <h2>{product.name}</h2>
      <p>{product.description}</p>
      <p className="price">${product.price}</p>
    </div>
  );
}
```

#### Topik 4.3: Protected Routes & Authentication
**Durasi**: 1 hari  
**Materi**:
- Authentication flow di React
- Private routes
- Redirect non-authenticated users
- Persisting authentication state
- Role-based authorization

**Hands-on Practice**:
```jsx
const AuthContext = createContext(null);

function AuthProvider({ children }) {
  const [user, setUser] = useState(null);
  
  // Check for saved auth on initial load
  useEffect(() => {
    const savedUser = localStorage.getItem('user');
    if (savedUser) {
      setUser(JSON.parse(savedUser));
    }
  }, []);
  
  const login = async (credentials) => {
    // Call to auth API
    const response = await authService.login(credentials);
    const userData = response.data;
    
    // Save user in state and localStorage
    setUser(userData);
    localStorage.setItem('user', JSON.stringify(userData));
    return userData;
  };
  
  const logout = () => {
    setUser(null);
    localStorage.removeItem('user');
  };
  
  const value = {
    user,
    isAuthenticated: !!user,
    login,
    logout
  };
  
  return (
    <AuthContext.Provider value={value}>
      {children}
    </AuthContext.Provider>
  );
}

function useAuth() {
  return useContext(AuthContext);
}

function ProtectedRoute({ children }) {
  const { isAuthenticated } = useAuth();
  const location = useLocation();
  
  if (!isAuthenticated) {
    return <Navigate to="/login" state={{ from: location }} replace />;
  }
  
  return children;
}

function App() {
  return (
    <AuthProvider>
      <BrowserRouter>
        <Routes>
          <Route path="/" element={<MainLayout />}>
            <Route index element={<Home />} />
            <Route path="login" element={<Login />} />
            <Route path="dashboard" element={
              <ProtectedRoute>
                <Dashboard />
              </ProtectedRoute>
            } />
            <Route path="profile" element={
              <ProtectedRoute>
                <Profile />
              </ProtectedRoute>
            } />
          </Route>
        </Routes>
      </BrowserRouter>
    </AuthProvider>
  );
}
```

#### Topik 4.4: Code Splitting & Lazy Loading
**Durasi**: 1 hari  
**Materi**:
- Bundling concepts
- React.lazy
- Suspense component
- Route-based code splitting
- Preloading chunks
- Error boundaries

**Hands-on Practice**:
```jsx
import React, { Suspense, lazy } from 'react';
import { BrowserRouter, Routes, Route } from 'react-router-dom';
import LoadingFallback from './LoadingFallback';
import ErrorBoundary from './ErrorBoundary';

// Lazy load components
const Home = lazy(() => import('./pages/Home'));
const About = lazy(() => import('./pages/About'));
const Products = lazy(() => import('./pages/Products'));
const ProductDetail = lazy(() => import('./pages/ProductDetail'));
const Contact = lazy(() => import('./pages/Contact'));
const NotFound = lazy(() => import('./pages/NotFound'));

function App() {
  return (
    <BrowserRouter>
      <ErrorBoundary>
        <Suspense fallback={<LoadingFallback />}>
          <Routes>
            <Route path="/" element={<MainLayout />}>
              <Route index element={<Home />} />
              <Route path="about" element={<About />} />
              <Route path="products" element={<Products />} />
              <Route path="products/:id" element={<ProductDetail />} />
              <Route path="contact" element={<Contact />} />
              <Route path="*" element={<NotFound />} />
            </Route>
          </Routes>
        </Suspense>
      </ErrorBoundary>
    </BrowserRouter>
  );
}
```

**Project Modul 4**:  
Membuat Multi-page Application dengan React Router:
- Implementasi routing untuk multiple pages
- Login/registration pages dengan authentication
- Dashboard dengan protected routes
- Dynamic routes dengan parameter
- Lazy loading untuk semua pages
- Custom 404 page
- Breadcrumb navigation

### MODUL 5: STATE MANAGEMENT

#### Topik 5.1: React Context API
**Durasi**: 2 hari  
**Materi**:
- Context API basics
- createContext dan useContext
- Context Provider pattern
- Multiple contexts
- Context vs prop drilling
- Performance considerations

**Hands-on Practice**:
```jsx
// ThemeContext.js
import { createContext, useContext, useState } from 'react';

const ThemeContext = createContext();

export function ThemeProvider({ children }) {
  const [theme, setTheme] = useState('light');
  
  const toggleTheme = () => {
    setTheme(prevTheme => prevTheme === 'light' ? 'dark' : 'light');
  };
  
  const value = {
    theme,
    toggleTheme
  };
  
  return (
    <ThemeContext.Provider value={value}>
      {children}
    </ThemeContext.Provider>
  );
}

export function useTheme() {
  const context = useContext(ThemeContext);
  if (context === undefined) {
    throw new Error('useTheme must be used within a ThemeProvider');
  }
  return context;
}

// App.js
function App() {
  return (
    <ThemeProvider>
      <MainApp />
    </ThemeProvider>
  );
}

// ThemedButton.js
function ThemedButton({ children, ...props }) {
  const { theme, toggleTheme } = useTheme();
  
  return (
    <button
      className={`btn btn-${theme}`}
      onClick={toggleTheme}
      {...props}
    >
      {children}
    </button>
  );
}
```

#### Topik 5.2: Introduction to Redux
**Durasi**: 2 hari  
**Materi**:
- Redux principles
- Actions, reducers, dan store
- connect HOC
- mapStateToProps dan mapDispatchToProps
- Redux DevTools
- Redux middleware

**Hands-on Practice**:
```jsx
// actions.js
export const ADD_TODO = 'ADD_TODO';
export const TOGGLE_TODO = 'TOGGLE_TODO';
export const REMOVE_TODO = 'REMOVE_TODO';

export const addTodo = (text) => ({
  type: ADD_TODO,
  payload: {
    id: Date.now(),
    text,
    completed: false
  }
});

export const toggleTodo = (id) => ({
  type: TOGGLE_TODO,
  payload: { id }
});

export const removeTodo = (id) => ({
  type: REMOVE_TODO,
  payload: { id }
});

// reducers.js
const initialState = {
  todos: []
};

export function todoReducer(state = initialState, action) {
  switch (action.type) {
    case ADD_TODO:
      return {
        ...state,
        todos: [...state.todos, action.payload]
      };
      
    case TOGGLE_TODO:
      return {
        ...state,
        todos: state.todos.map(todo =>
          todo.id === action.payload.id
            ? { ...todo, completed: !todo.completed }
            : todo
        )
      };
      
    case REMOVE_TODO:
      return {
        ...state,
        todos: state.todos.filter(todo => todo.id !== action.payload.id)
      };
      
    default:
      return state;
  }
}

// store.js
import { createStore } from 'redux';
import { todoReducer } from './reducers';

const store = createStore(
  todoReducer,
  window.__REDUX_DEVTOOLS_EXTENSION__ && window.__REDUX_DEVTOOLS_EXTENSION__()
);

export default store;

// TodoList.js (with connect)
import { connect } from 'react-redux';
import { toggleTodo, removeTodo } from './actions';

function TodoList({ todos, toggleTodo, removeTodo }) {
  return (
    <ul className="todo-list">
      {todos.map(todo => (
        <li key={todo.id} className={todo.completed ? 'completed' : ''}>
          <input
            type="checkbox"
            checked={todo.completed}
            onChange={() => toggleTodo(todo.id)}
          />
          <span>{todo.text}</span>
          <button onClick={() => removeTodo(todo.id)}>Delete</button>
        </li>
      ))}
    </ul>
  );
}

const mapStateToProps = (state) => ({
  todos: state.todos
});

const mapDispatchToProps = {
  toggleTodo,
  removeTodo
};

export default connect(mapStateToProps, mapDispatchToProps)(TodoList);
```

#### Topik 5.3: Modern Redux dengan Hooks
**Durasi**: 2 hari  
**Materi**:
- useSelector dan useDispatch
- Redux hooks vs connect
- Selecting data efficiently
- Memoization dan performance
- Redux best practices

**Hands-on Practice**:
```jsx
// TodoList.js (with hooks)
import { useSelector, useDispatch } from 'react-redux';
import { toggleTodo, removeTodo } from './actions';

function TodoList() {
  const todos = useSelector(state => state.todos);
  const dispatch = useDispatch();
  
  return (
    <ul className="todo-list">
      {todos.map(todo => (
        <li key={todo.id} className={todo.completed ? 'completed' : ''}>
          <input
            type="checkbox"
            checked={todo.completed}
            onChange={() => dispatch(toggleTodo(todo.id))}
          />
          <span>{todo.text}</span>
          <button onClick={() => dispatch(removeTodo(todo.id))}>
            Delete
          </button>
        </li>
      ))}
    </ul>
  );
}

// AddTodo.js
function AddTodo() {
  const [text, setText] = useState('');
  const dispatch = useDispatch();
  
  const handleSubmit = (e) => {
    e.preventDefault();
    if (!text.trim()) return;
    
    dispatch(addTodo(text));
    setText('');
  };
  
  return (
    <form onSubmit={handleSubmit}>
      <input
        type="text"
        value={text}
        onChange={(e) => setText(e.target.value)}
        placeholder="Add new todo"
      />
      <button type="submit">Add</button>
    </form>
  );
}
```

#### Topik 5.4: Redux Toolkit
**Durasi**: 2 hari  
**Materi**:
- configureStore
- createSlice
- createAsyncThunk
- Redux DevTools integration
- Immutability dengan Immer
- createEntityAdapter

**Hands-on Practice**:
```jsx
// todosSlice.js
import { createSlice, createAsyncThunk } from '@reduxjs/toolkit';
import todoApi from '../api/todoApi';

export const fetchTodos = createAsyncThunk(
  'todos/fetchTodos',
  async () => {
    const response = await todoApi.getTodos();
    return response.data;
  }
);

export const addNewTodo = createAsyncThunk(
  'todos/addNewTodo',
  async (text) => {
    const response = await todoApi.addTodo({ text, completed: false });
    return response.data;
  }
);

const todosSlice = createSlice({
  name: 'todos',
  initialState: {
    items: [],
    status: 'idle', // 'idle' | 'loading' | 'succeeded' | 'failed'
    error: null
  },
  reducers: {
    // Immer lets us write "mutating" logic
    toggleTodo: (state, action) => {
      const todo = state.items.find(todo => todo.id === action.payload);
      if (todo) {
        todo.completed = !todo.completed;
      }
    },
    removeTodo: (state, action) => {
      state.items = state.items.filter(todo => todo.id !== action.payload);
    }
  },
  extraReducers: (builder) => {
    builder
      .addCase(fetchTodos.pending, (state) => {
        state.status = 'loading';
      })
      .addCase(fetchTodos.fulfilled, (state, action) => {
        state.status = 'succeeded';
        state.items = action.payload;
      })
      .addCase(fetchTodos.rejected, (state, action) => {
        state.status = 'failed';
        state.error = action.error.message;
      })
      .addCase(addNewTodo.fulfilled, (state, action) => {
        state.items.push(action.payload);
      });
  }
});

export const { toggleTodo, removeTodo } = todosSlice.actions;
export default todosSlice.reducer;

// store.js
import { configureStore } from '@reduxjs/toolkit';
import todosReducer from './todosSlice';

export const store = configureStore({
  reducer: {
    todos: todosReducer
  }
});

// TodoList.js
function TodoList() {
  const dispatch = useDispatch();
  const { items, status, error } = useSelector(state => state.todos);
  
  useEffect(() => {
    if (status === 'idle') {
      dispatch(fetchTodos());
    }
  }, [status, dispatch]);
  
  if (status === 'loading') {
    return <div>Loading...</div>;
  }
  
  if (status === 'failed') {
    return <div>Error: {error}</div>;
  }
  
  return (
    <ul className="todo-list">
      {items.map(todo => (
        <li key={todo.id} className={todo.completed ? 'completed' : ''}>
          <input
            type="checkbox"
            checked={todo.completed}
            onChange={() => dispatch(toggleTodo(todo.id))}
          />
          <span>{todo.text}</span>
          <button onClick={() => dispatch(removeTodo(todo.id))}>
            Delete
          </button>
        </li>
      ))}
    </ul>
  );
}
```

#### Topik 5.5: Asynchronous Redux
**Durasi**: 2 hari  
**Materi**:
- Redux middleware concepts
- Thunks vs Sagas
- Redux Thunk middleware
- Error handling in async actions
- Loading states
- Optimistic updates

**Hands-on Practice**:
```jsx
// With Redux Thunk (without toolkit)
export const fetchTodos = () => async (dispatch) => {
  dispatch({ type: 'FETCH_TODOS_START' });
  
  try {
    const response = await fetch('/api/todos');
    const data = await response.json();
    
    dispatch({
      type: 'FETCH_TODOS_SUCCESS',
      payload: data
    });
  } catch (error) {
    dispatch({
      type: 'FETCH_TODOS_FAILURE',
      payload: error.message
    });
  }
};

// Optimistic update example
export const toggleTodoOptimistic = (id) => async (dispatch, getState) => {
  const todo = getState().todos.items.find(todo => todo.id === id);
  
  // Optimistically update UI
  dispatch({
    type: 'TOGGLE_TODO',
    payload: { id }
  });
  
  try {
    // API call to persist the change
    await fetch(`/api/todos/${id}`, {
      method: 'PATCH',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({ completed: !todo.completed })
    });
  } catch (error) {
    // Revert on failure
    dispatch({
      type: 'TOGGLE_TODO',
      payload: { id }
    });
    
    dispatch({
      type: 'API_ERROR',
      payload: error.message
    });
  }
};
```

**Project Modul 5**:  
Membuat E-Commerce App dengan state management kompleks:
- Cart functionality dengan Redux
- Product listing dengan filtering dan sorting
- User authentication state management
- Wishlists dan saved items
- Order processing flow
- Product reviews dan ratings

### MODUL 6: DATA FETCHING & API INTEGRATION

#### Topik 6.1: Fetching Data in React
**Durasi**: 1 hari  
**Materi**:
- Fetch API
- Axios library
- Error handling
- Loading states
- AbortController untuk cancellation
- Handling race conditions

**Hands-on Practice**:
```jsx
function UserProfile({ userId }) {
  const [data, setData] = useState(null);
  const [loading, setLoading] = useState(true);
  const [error, setError] = useState(null);
  
  useEffect(() => {
    let isMounted = true;
    const controller = new AbortController();
    const signal = controller.signal;
    
    async function fetchData() {
      setLoading(true);
      
      try {
        const response = await fetch(`/api/users/${userId}`, { signal });
        
        if (!response.ok) {
          throw new Error(`HTTP error! status: ${response.status}`);
        }
        
        const result = await response.json();
        
        if (isMounted) {
          setData(result);
          setError(null);
        }
      } catch (error) {
        if (error.name !== 'AbortError' && isMounted) {
          setError(error.message);
          setData(null);
        }
      } finally {
        if (isMounted) {
          setLoading(false);
        }
      }
    }
    
    fetchData();
    
    // Cleanup function
    return () => {
      isMounted = false;
      controller.abort();
    };
  }, [userId]);
  
  if (loading) return <p>Loading...</p>;
  if (error) return <p>Error: {error}</p>;
  if (!data) return null;
  
  return (
    <div>
      <h1>{data.name}</h1>
      <p>Email: {data.email}</p>
      {/* Other user info */}
    </div>
  );
}
```

#### Topik 6.2: Custom Hooks untuk Data Fetching
**Durasi**: 2 hari  
**Materi**:
- Creating reusable fetch hooks
- Separation of concerns
- Parameterized fetch hooks
- Caching results
- Polling dan refresh strategies
- Sequential vs parallel data fetching

**Hands-on Practice**:
```jsx
// useFetch.js - Basic fetch hook
function useFetch(url) {
  const [data, setData] = useState(null);
  const [loading, setLoading] = useState(true);
  const [error, setError] = useState(null);
  
  useEffect(() => {
    let isMounted = true;
    const controller = new AbortController();
    
    async function fetchData() {
      setLoading(true);
      
      try {
        const response = await fetch(url, { signal: controller.signal });
        
        if (!response.ok) {
          throw new Error(`HTTP error! status: ${response.status}`);
        }
        
        const result = await response.json();
        
        if (isMounted) {
          setData(result);
          setError(null);
        }
      } catch (error) {
        if (error.name !== 'AbortError' && isMounted) {
          setError(error.message);
        }
      } finally {
        if (isMounted) {
          setLoading(false);
        }
      }
    }
    
    fetchData();
    
    return () => {
      isMounted = false;
      controller.abort();
    };
  }, [url]);
  
  return { data, loading, error };
}

// useResource.js - More advanced hook
function useResource(resourceType, id) {
  const [resource, setResource] = useState(null);
  const [loading, setLoading] = useState(true);
  const [error, setError] = useState(null);
  
  useEffect(() => {
    let isMounted = true;
    const controller = new AbortController();
    
    async function fetchResource() {
      if (!id) return;
      
      setLoading(true);
      
      try {
        const response = await fetch(`/api/${resourceType}/${id}`, {
          signal: controller.signal
        });
        
        if (!response.ok) {
          throw new Error(`HTTP error! status: ${response.status}`);
        }
        
        const data = await response.json();
        
        if (isMounted) {
          setResource(data);
          setError(null);
        }
      } catch (error) {
        if (error.name !== 'AbortError' && isMounted) {
          setError(error.message);
          setResource(null);
        }
      } finally {
        if (isMounted) {
          setLoading(false);
        }
      }
    }
    
    fetchResource();
    
    return () => {
      isMounted = false;
      controller.abort();
    };
  }, [resourceType, id]);
  
  return {
    data: resource,
    loading,
    error,
    refetch: () => {
      setLoading(true);
      // Re-run the effect by updating a ref
    }
  };
}

// Usage
function UserProfile({ userId }) {
  const { data: user, loading, error } = useResource('users', userId);
  
  // Dependent query - fetch user's posts once we have the user
  const { data: posts } = useResource('posts', user ? user.id : null);
  
  if (loading) return <p>Loading...</p>;
  if (error) return <p>Error: {error}</p>;
  if (!user) return null;
  
  return (
    <div>
      <h1>{user.name}</h1>
      <p>Email: {user.email}</p>
      
      <h2>Posts</h2>
      {posts ? (
        <ul>
          {posts.map(post => (
            <li key={post.id}>{post.title}</li>
          ))}
        </ul>
      ) : (
        <p>Loading posts...</p>
      )}
    </div>
  );
}
```

#### Topik 6.3: React Query
**Durasi**: 2 hari  
**Materi**:
- React Query basics
- Queries vs Mutations
- Caching dan stale data
- Refetching strategies
- Pagination dan infinite scroll
- Optimistic updates
- Dependent queries

**Hands-on Practice**:
```jsx
// React Query setup
import {
  QueryClient,
  QueryClientProvider,
  useQuery,
  useMutation,
  useQueryClient
} from 'react-query';

const queryClient = new QueryClient({
  defaultOptions: {
    queries: {
      staleTime: 1000 * 60 * 5, // 5 minutes
      cacheTime: 1000 * 60 * 30, // 30 minutes
      retry: 2,
      refetchOnWindowFocus: true
    }
  }
});

function App() {
  return (
    <QueryClientProvider client={queryClient}>
      <TodoApp />
    </QueryClientProvider>
  );
}

// API functions
const fetchTodos = async () => {
  const response = await fetch('/api/todos');
  if (!response.ok) {
    throw new Error('Network response was not ok');
  }
  return response.json();
};

const addTodo = async (newTodo) => {
  const response = await fetch('/api/todos', {
    method: 'POST',
    headers: { 'Content-Type': 'application/json' },
    body: JSON.stringify(newTodo)
  });
  if (!response.ok) {
    throw new Error('Failed to add todo');
  }
  return response.json();
};

const updateTodo = async (todo) => {
  const response = await fetch(`/api/todos/${todo.id}`, {
    method: 'PUT',
    headers: { 'Content-Type': 'application/json' },
    body: JSON.stringify(todo)
  });
  if (!response.ok) {
    throw new Error('Failed to update todo');
  }
  return response.json();
};

// Components
function TodoApp() {
  const queryClient = useQueryClient();
  
  // Query - fetching data
  const {
    data: todos,
    isLoading,
    isError,
    error,
    refetch
  } = useQuery('todos', fetchTodos);
  
  // Mutation - adding a todo
  const addMutation = useMutation(addTodo, {
    // When mutate is called:
    onMutate: async (newTodo) => {
      // Cancel any outgoing refetches
      await queryClient.cancelQueries('todos');
      
      // Snapshot the previous value
      const previousTodos = queryClient.getQueryData('todos');
      
      // Optimistically update to the new value
      queryClient.setQueryData('todos', old => [
        ...old,
        { id: Date.now(), ...newTodo }
      ]);
      
      // Return context with the snapshotted value
      return { previousTodos };
    },
    // If the mutation fails, use the context returned from onMutate to roll back
    onError: (err, newTodo, context) => {
      queryClient.setQueryData('todos', context.previousTodos);
    },
    // Always refetch after error or success:
    onSettled: () => {
      queryClient.invalidateQueries('todos');
    },
  });
  
  // Mutation - toggling a todo
  const updateMutation = useMutation(updateTodo, {
    onMutate: async (updatedTodo) => {
      await queryClient.cancelQueries('todos');
      const previousTodos = queryClient.getQueryData('todos');
      
      queryClient.setQueryData('todos', old =>
        old.map(todo =>
          todo.id === updatedTodo.id ? updatedTodo : todo
        )
      );
      
      return { previousTodos };
    },
    onError: (err, updatedTodo, context) => {
      queryClient.setQueryData('todos', context.previousTodos);
    },
    onSettled: () => {
      queryClient.invalidateQueries('todos');
    },
  });
  
  const handleAddTodo = (text) => {
    addMutation.mutate({ text, completed: false });
  };
  
  const handleToggle = (todo) => {
    updateMutation.mutate({
      ...todo,
      completed: !todo.completed
    });
  };
  
  if (isLoading) return <p>Loading...</p>;
  if (isError) return <p>Error: {error.message}</p>;
  
  return (
    <div>
      <button onClick={() => refetch()}>Refresh</button>
      
      <AddTodoForm onAdd={handleAddTodo} />
      
      <ul>
        {todos.map(todo => (
          <li
            key={todo.id}
            style={{ textDecoration: todo.completed ? 'line-through' : 'none' }}
            onClick={() => handleToggle(todo)}
          >
            {todo.text}
          </li>
        ))}
      </ul>
    </div>
  );
}
```

#### Topik 6.4: Authentication
**Durasi**: 2 hari  
**Materi**:
- JWT Authentication
- OAuth flows
- Authentication state management
- Protected routes
- Refresh tokens
- Persistent login
- Security considerations

**Hands-on Practice**:
```jsx
import { createContext, useContext, useState, useEffect } from 'react';

// Create auth context
const AuthContext = createContext(null);

export function AuthProvider({ children }) {
  const [user, setUser] = useState(null);
  const [loading, setLoading] = useState(true);
  
  // Check if user is already logged in
  useEffect(() => {
    async function loadUserFromToken() {
      const token = localStorage.getItem('token');
      
      if (!token) {
        setLoading(false);
        return;
      }
      
      try {
        // Validate token and get user info
        const response = await fetch('/api/auth/me', {
          headers: {
            'Authorization': `Bearer ${token}`
          }
        });
        
        if (!response.ok) {
          throw new Error('Invalid token');
        }
        
        const userData = await response.json();
        setUser(userData);
      } catch (error) {
        console.error('Failed to load user', error);
        localStorage.removeItem('token');
      } finally {
        setLoading(false);
      }
    }
    
    loadUserFromToken();
  }, []);
  
  // Login function
  const login = async (credentials) => {
    const response = await fetch('/api/auth/login', {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json'
      },
      body: JSON.stringify(credentials)
    });
    
    if (!response.ok) {
      throw new Error('Login failed');
    }
    
    const { token, user: userData } = await response.json();
    
    // Store token in localStorage
    localStorage.setItem('token', token);
    
    // Set user state
    setUser(userData);
    
    return userData;
  };
  
  // Logout function
  const logout = () => {
    localStorage.removeItem('token');
    setUser(null);
  };
  
  // Registration function
  const register = async (userData) => {
    const response = await fetch('/api/auth/register', {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json'
      },
      body: JSON.stringify(userData)
    });
    
    if (!response.ok) {
      const error = await response.json();
      throw new Error(error.message || 'Registration failed');
    }
    
    const { token, user: newUser } = await response.json();
    
    localStorage.setItem('token', token);
    setUser(newUser);
    
    return newUser;
  };
  
  const value = {
    user,
    loading,
    login,
    logout,
    register,
    isAuthenticated: !!user
  };
  
  return (
    <AuthContext.Provider value={value}>
      {children}
    </AuthContext.Provider>
  );
}

// Custom hook to use the auth context
export function useAuth() {
  const context = useContext(AuthContext);
  if (context === undefined) {
    throw new Error('useAuth must be used within an AuthProvider');
  }
  return context;
}

// Login form component
function LoginForm() {
  const { login } = useAuth();
  const [credentials, setCredentials] = useState({
    email: '',
    password: ''
  });
  const [error, setError] = useState('');
  const [loading, setLoading] = useState(false);
  const navigate = useNavigate();
  
  const handleChange = (e) => {
    const { name, value } = e.target;
    setCredentials(prev => ({
      ...prev,
      [name]: value
    }));
  };
  
  const handleSubmit = async (e) => {
    e.preventDefault();
    setError('');
    setLoading(true);
    
    try {
      await login(credentials);
      navigate('/dashboard');
    } catch (error) {
      setError(error.message);
    } finally {
      setLoading(false);
    }
  };
  
  return (
    <form onSubmit={handleSubmit}>
      {error && <p className="error">{error}</p>}
      
      <div>
        <label htmlFor="email">Email</label>
        <input
          type="email"
          id="email"
          name="email"
          value={credentials.email}
          onChange={handleChange}
          required
        />
      </div>
      
      <div>
        <label htmlFor="password">Password</label>
        <input
          type="password"
          id="password"
          name="password"
          value={credentials.password}
          onChange={handleChange}
          required
        />
      </div>
      
      <button type="submit" disabled={loading}>
        {loading ? 'Logging in...' : 'Log In'}
      </button>
    </form>
  );
}
```

**Project Modul 6**:  
Membuat Dashboard App dengan integrasi API:
- Authentication dengan JWT
- Admin dashboard dengan CRUD operations
- Data visualization dengan real-time updates
- Search dan filtering dengan API parameters
- Pagination dan infinite scroll
- Optimistic UI updates
- Error handling dan retry mechanisms

# MODUL 7: ADVANCED HOOKS & PATTERNS

## Informasi Umum
- **Durasi**: 2 minggu (Minggu 15-16)
- **Tujuan**: Memahami hooks lanjutan dan pattern design React
- **Project Akhir**: Library of reusable React components

## Daftar Isi
1. [useCallback, useMemo, dan useRef](#1-usecallback-usememo-dan-useref)
2. [Custom Hooks Development](#2-custom-hooks-development)
3. [Higher-Order Components](#3-higher-order-components)
4. [Render Props Pattern](#4-render-props-pattern)
5. [Compound Components](#5-compound-components)
6. [Control Props Pattern](#6-control-props-pattern)
7. [Project: Library of Reusable Components](#7-project-library-of-reusable-components)

---

## 1. useCallback, useMemo, dan useRef

### useCallback

`useCallback` adalah hook React yang memungkinkan kita menyimpan fungsi dalam memori (memoize) sehingga fungsi tersebut tidak dibuat ulang pada setiap render kecuali dependensinya berubah.

#### Kenapa menggunakan useCallback?

- Mencegah re-render yang tidak perlu pada child components
- Meningkatkan performa aplikasi terutama untuk fungsi yang dioper sebagai props
- Mencegah side effect yang tidak diinginkan

#### Contoh penggunaan:

```jsx
import React, { useState, useCallback } from 'react';

function ParentComponent() {
  const [count, setCount] = useState(0);
  
  // Tanpa useCallback - fungsi ini dibuat ulang setiap render
  // const handleClick = () => {
  //   setCount(count + 1);
  // };
  
  // Dengan useCallback - fungsi hanya dibuat ulang jika dependensi berubah
  const handleClick = useCallback(() => {
    setCount(prevCount => prevCount + 1);
  }, []);
  
  return (
    <div>
      <p>Count: {count}</p>
      <ChildComponent onClick={handleClick} />
    </div>
  );
}

function ChildComponent({ onClick }) {
  console.log('Child component rendered');
  return <button onClick={onClick}>Increment</button>;
}
```

### useMemo

`useMemo` adalah hook yang memungkinkan kita menyimpan hasil perhitungan dalam memori dan hanya menghitung ulang ketika dependensinya berubah.

#### Kenapa menggunakan useMemo?

- Menghindari perhitungan yang mahal pada setiap render
- Mengoptimalkan performa untuk operasi yang berat
- Menjaga referential equality untuk objek kompleks

#### Contoh penggunaan:

```jsx
import React, { useState, useMemo } from 'react';

function ExpensiveCalculation({ list, filter }) {
  // Tanpa useMemo - perhitungan dilakukan setiap render
  // const filteredList = list.filter(item => item.includes(filter));
  
  // Dengan useMemo - perhitungan hanya dilakukan jika list atau filter berubah
  const filteredList = useMemo(() => {
    console.log('Filtering list...');
    return list.filter(item => item.includes(filter));
  }, [list, filter]);
  
  return (
    <ul>
      {filteredList.map((item, index) => (
        <li key={index}>{item}</li>
      ))}
    </ul>
  );
}
```

### useRef

`useRef` adalah hook yang memberikan kita objek ref yang stabil (tidak berubah antar render) dengan property `.current` yang dapat dimutasi.

#### Penggunaan useRef:

1. **Mengakses DOM elements**:
   Mendapatkan akses langsung ke elemen DOM

2. **Menyimpan nilai yang persistant**:
   Menyimpan data yang tetap ada antar render tanpa menyebabkan re-render

3. **Menyimpan nilai previous**:
   Menyimpan nilai sebelumnya dari suatu state

#### Contoh penggunaan:

```jsx
import React, { useRef, useEffect, useState } from 'react';

function TextInputWithFocusButton() {
  // 1. Mengakses DOM element
  const inputRef = useRef(null);
  
  const focusInput = () => {
    inputRef.current.focus();
  };

  // 2. Menyimpan nilai yang persistent
  const [count, setCount] = useState(0);
  const countRef = useRef(0);
  
  const incrementWithState = () => {
    setCount(count + 1); // Menyebabkan re-render
  };
  
  const incrementWithRef = () => {
    countRef.current += 1; // Tidak menyebabkan re-render
    console.log('Current ref value:', countRef.current);
  };
  
  // 3. Menyimpan nilai previous
  const prevCountRef = useRef();
  
  useEffect(() => {
    prevCountRef.current = count;
  }, [count]);
  
  return (
    <div>
      <input ref={inputRef} type="text" />
      <button onClick={focusInput}>Focus Input</button>
      
      <div>
        <p>State Count: {count}</p>
        <p>Previous State Count: {prevCountRef.current}</p>
        <button onClick={incrementWithState}>Increment State</button>
      </div>
      
      <div>
        <p>Ref Count (check console): {countRef.current}</p>
        <button onClick={incrementWithRef}>Increment Ref</button>
      </div>
    </div>
  );
}
```

---

## 2. Custom Hooks Development

Custom hooks adalah fungsi JavaScript yang dimulai dengan `use` dan dapat memanfaatkan hooks lain dari React. Mereka memungkinkan kita untuk mengekstrak logika komponen ke fungsi yang dapat digunakan kembali.

### Keuntungan Custom Hooks:

- **Reusability**: Menggunakan kembali logika antar komponen
- **Separation of Concerns**: Memisahkan logika dari tampilan UI
- **Clean Code**: Membuat komponen lebih ringkas dan fokus

### Contoh Basic Custom Hook:

```jsx
// 1. useToggle - untuk menangani toggle state (on/off)
import { useState } from 'react';

function useToggle(initialValue = false) {
  const [value, setValue] = useState(initialValue);
  
  const toggle = () => {
    setValue(prevValue => !prevValue);
  };
  
  return [value, toggle];
}

// Cara penggunaan:
function ToggleComponent() {
  const [isOn, toggleIsOn] = useToggle();
  
  return (
    <button onClick={toggleIsOn}>
      {isOn ? 'ON' : 'OFF'}
    </button>
  );
}
```

### Contoh Custom Hook untuk Data Fetching:

```jsx
import { useState, useEffect } from 'react';

function useFetch(url) {
  const [data, setData] = useState(null);
  const [loading, setLoading] = useState(true);
  const [error, setError] = useState(null);

  useEffect(() => {
    const fetchData = async () => {
      try {
        setLoading(true);
        const response = await fetch(url);
        
        if (!response.ok) {
          throw new Error(`HTTP error! Status: ${response.status}`);
        }
        
        const result = await response.json();
        setData(result);
        setError(null);
      } catch (err) {
        setError(err.message);
        setData(null);
      } finally {
        setLoading(false);
      }
    };

    fetchData();
  }, [url]);

  return { data, loading, error };
}

// Cara penggunaan:
function UserComponent() {
  const { data: user, loading, error } = useFetch('https://api.example.com/user/1');
  
  if (loading) return <p>Loading...</p>;
  if (error) return <p>Error: {error}</p>;
  
  return (
    <div>
      <h1>{user.name}</h1>
      <p>{user.email}</p>
    </div>
  );
}
```

### Custom Hook untuk Form:

```jsx
import { useState } from 'react';

function useForm(initialValues) {
  const [values, setValues] = useState(initialValues);
  
  const handleChange = (e) => {
    const { name, value } = e.target;
    setValues({
      ...values,
      [name]: value
    });
  };
  
  const resetForm = () => {
    setValues(initialValues);
  };
  
  return {
    values,
    handleChange,
    resetForm
  };
}

// Cara penggunaan:
function ContactForm() {
  const { values, handleChange, resetForm } = useForm({
    name: '',
    email: '',
    message: ''
  });
  
  const handleSubmit = (e) => {
    e.preventDefault();
    console.log('Form submitted with values:', values);
    resetForm();
  };
  
  return (
    <form onSubmit={handleSubmit}>
      <input
        type="text"
        name="name"
        value={values.name}
        onChange={handleChange}
        placeholder="Name"
      />
      <input
        type="email"
        name="email"
        value={values.email}
        onChange={handleChange}
        placeholder="Email"
      />
      <textarea
        name="message"
        value={values.message}
        onChange={handleChange}
        placeholder="Message"
      />
      <button type="submit">Submit</button>
    </form>
  );
}
```

---

## 3. Higher-Order Components

Higher-Order Component (HOC) adalah fungsi yang menerima sebuah komponen dan mengembalikan komponen baru dengan fungsionalitas tambahan.

### Keuntungan HOC:

- **Code Reuse**: Menggunakan kembali logika antar komponen
- **Separation of Concerns**: Memisahkan logika dari tampilan UI
- **Komposisi**: Dapat menggabungkan beberapa HOC

### Contoh Basic HOC:

```jsx
// HOC untuk menambahkan props extraData ke komponen
function withExtraData(WrappedComponent) {
  // Mengembalikan komponen baru
  return function WithExtraData(props) {
    const extraData = { message: "This is extra data from HOC" };
    
    // Menggabungkan props dan extraData
    return <WrappedComponent {...props} extraData={extraData} />;
  };
}

// Komponen original
function DisplayMessage({ message, extraData }) {
  return (
    <div>
      <p>Original message: {message}</p>
      <p>Extra data: {extraData.message}</p>
    </div>
  );
}

// Komponen yang sudah di-enhance dengan HOC
const EnhancedDisplayMessage = withExtraData(DisplayMessage);

// Penggunaan
function App() {
  return <EnhancedDisplayMessage message="Hello World!" />;
}
```

### HOC untuk Loading State:

```jsx
function withLoading(WrappedComponent) {
  return function WithLoading({ isLoading, ...props }) {
    if (isLoading) {
      return <div>Loading...</div>;
    }
    
    return <WrappedComponent {...props} />;
  };
}

// Komponen asli
function UserList({ users }) {
  return (
    <ul>
      {users.map(user => (
        <li key={user.id}>{user.name}</li>
      ))}
    </ul>
  );
}

// Komponen yang ditingkatkan
const UserListWithLoading = withLoading(UserList);

// Penggunaan
function App() {
  const [isLoading, setIsLoading] = useState(true);
  const [users, setUsers] = useState([]);
  
  useEffect(() => {
    // Fetch users
    fetch('https://api.example.com/users')
      .then(response => response.json())
      .then(data => {
        setUsers(data);
        setIsLoading(false);
      });
  }, []);
  
  return <UserListWithLoading isLoading={isLoading} users={users} />;
}
```

### HOC untuk Authentication:

```jsx
function withAuth(WrappedComponent) {
  return function WithAuth(props) {
    // Logika authentication
    const [isAuthenticated, setIsAuthenticated] = useState(false);
    
    // Cek apakah user terautentikasi
    useEffect(() => {
      const token = localStorage.getItem('token');
      setIsAuthenticated(!!token);
    }, []);
    
    // Jika tidak terautentikasi, redirect ke login
    if (!isAuthenticated) {
      return (
        <div>
          <p>Please login to view this page</p>
          <button onClick={() => console.log('Navigate to login')}>
            Login
          </button>
        </div>
      );
    }
    
    // Jika terautentikasi, render komponen yang di-wrap
    return <WrappedComponent {...props} />;
  };
}

// Komponen Dashboard yang memerlukan authentication
function Dashboard() {
  return <div>Welcome to your Dashboard!</div>;
}

// Dashboard dengan authentication
const AuthenticatedDashboard = withAuth(Dashboard);
```

---

## 4. Render Props Pattern

Render Props adalah pattern dimana sebuah komponen menerima fungsi sebagai prop yang merender apa yang akan ditampilkan komponen tersebut.

### Keuntungan Render Props:

- **Reusability**: Memungkinkan penggunaan ulang logika antar komponen
- **Flexibility**: Memberikan kontrol yang lebih besar kepada komponen parent
- **Composition**: Mudah dikombinasikan dengan pattern lain

### Contoh Basic Render Props:

```jsx
import React, { useState } from 'react';

// Komponen dengan Render Props
function Counter({ render }) {
  const [count, setCount] = useState(0);
  
  const increment = () => setCount(count + 1);
  const decrement = () => setCount(count - 1);
  
  // Memanggil fungsi render dengan data yang dibutuhkan
  return render({ count, increment, decrement });
}

// Penggunaan
function App() {
  return (
    <Counter
      render={({ count, increment, decrement }) => (
        <div>
          <h1>Count: {count}</h1>
          <button onClick={increment}>Increment</button>
          <button onClick={decrement}>Decrement</button>
        </div>
      )}
    />
  );
}
```

### Alternatif dengan Children sebagai Function:

```jsx
function Counter({ children }) {
  const [count, setCount] = useState(0);
  
  const increment = () => setCount(count + 1);
  const decrement = () => setCount(count - 1);
  
  // Memanggil children sebagai fungsi
  return children({ count, increment, decrement });
}

// Penggunaan
function App() {
  return (
    <Counter>
      {({ count, increment, decrement }) => (
        <div>
          <h1>Count: {count}</h1>
          <button onClick={increment}>Increment</button>
          <button onClick={decrement}>Decrement</button>
        </div>
      )}
    </Counter>
  );
}
```

### Mouse Position dengan Render Props:

```jsx
function MouseTracker({ render }) {
  const [position, setPosition] = useState({ x: 0, y: 0 });
  
  useEffect(() => {
    const handleMouseMove = (event) => {
      setPosition({
        x: event.clientX,
        y: event.clientY
      });
    };
    
    window.addEventListener('mousemove', handleMouseMove);
    
    return () => {
      window.removeEventListener('mousemove', handleMouseMove);
    };
  }, []);
  
  return render(position);
}

// Penggunaan
function App() {
  return (
    <div>
      <h1>Move your mouse around!</h1>
      <MouseTracker
        render={({ x, y }) => (
          <p>Current mouse position: ({x}, {y})</p>
        )}
      />
    </div>
  );
}
```

---

## 5. Compound Components

Compound Components adalah pattern yang memungkinkan kita membuat komponen yang bekerja sama untuk menyediakan state dan fungsionalitas bersama, namun tetap mempertahankan flexibilitas dalam komposisi tampilan.

### Keuntungan Compound Components:

- **Flexibilitas**: Memberikan kontrol lebih kepada developer dalam menentukan struktur komponen
- **Implicit State Sharing**: Component children dapat mengakses state tanpa prop drilling
- **Semantic API**: Membuat API komponen lebih intuitif dan mudah dibaca

### Contoh Compound Components:

```jsx
import React, { createContext, useContext, useState } from 'react';

// Buat context
const TabsContext = createContext();

// Komponen utama
function Tabs({ children, defaultIndex = 0 }) {
  const [activeIndex, setActiveIndex] = useState(defaultIndex);
  
  // Nilai yang dishare ke komponen lain
  const value = {
    activeIndex,
    setActiveIndex
  };
  
  return (
    <TabsContext.Provider value={value}>
      <div className="tabs">{children}</div>
    </TabsContext.Provider>
  );
}

// Sub komponen untuk Tab List
Tabs.List = function TabList({ children }) {
  return <div className="tabs-list">{children}</div>;
};

// Sub komponen untuk Tab
Tabs.Tab = function Tab({ children, index }) {
  const { activeIndex, setActiveIndex } = useContext(TabsContext);
  const isActive = activeIndex === index;
  
  return (
    <button
      className={`tab ${isActive ? 'active' : ''}`}
      onClick={() => setActiveIndex(index)}
    >
      {children}
    </button>
  );
};

// Sub komponen untuk Tab Panels
Tabs.Panels = function TabPanels({ children }) {
  return <div className="tabs-panels">{children}</div>;
};

// Sub komponen untuk Tab Panel
Tabs.Panel = function TabPanel({ children, index }) {
  const { activeIndex } = useContext(TabsContext);
  
  if (activeIndex !== index) return null;
  
  return <div className="tab-panel">{children}</div>;
};

// Penggunaan
function App() {
  return (
    <Tabs defaultIndex={0}>
      <Tabs.List>
        <Tabs.Tab index={0}>Tab 1</Tabs.Tab>
        <Tabs.Tab index={1}>Tab 2</Tabs.Tab>
        <Tabs.Tab index={2}>Tab 3</Tabs.Tab>
      </Tabs.List>
      
      <Tabs.Panels>
        <Tabs.Panel index={0}>Content for Tab 1</Tabs.Panel>
        <Tabs.Panel index={1}>Content for Tab 2</Tabs.Panel>
        <Tabs.Panel index={2}>Content for Tab 3</Tabs.Panel>
      </Tabs.Panels>
    </Tabs>
  );
}
```

### Contoh Dropdown dengan Compound Components:

```jsx
import React, { createContext, useContext, useState } from 'react';

const DropdownContext = createContext();

function Dropdown({ children }) {
  const [isOpen, setIsOpen] = useState(false);
  
  return (
    <DropdownContext.Provider value={{ isOpen, setIsOpen }}>
      <div className="dropdown">{children}</div>
    </DropdownContext.Provider>
  );
}

Dropdown.Toggle = function Toggle({ children }) {
  const { isOpen, setIsOpen } = useContext(DropdownContext);
  
  return (
    <button onClick={() => setIsOpen(!isOpen)}>
      {children}
    </button>
  );
};

Dropdown.Menu = function Menu({ children }) {
  const { isOpen } = useContext(DropdownContext);
  
  if (!isOpen) return null;
  
  return <div className="dropdown-menu">{children}</div>;
};

Dropdown.Item = function Item({ children, onClick }) {
  const { setIsOpen } = useContext(DropdownContext);
  
  const handleClick = () => {
    onClick?.();
    setIsOpen(false);
  };
  
  return (
    <div className="dropdown-item" onClick={handleClick}>
      {children}
    </div>
  );
};

// Penggunaan
function App() {
  return (
    <Dropdown>
      <Dropdown.Toggle>Options â¼</Dropdown.Toggle>
      <Dropdown.Menu>
        <Dropdown.Item onClick={() => console.log('Option 1 clicked')}>
          Option 1
        </Dropdown.Item>
        <Dropdown.Item onClick={() => console.log('Option 2 clicked')}>
          Option 2
        </Dropdown.Item>
        <Dropdown.Item onClick={() => console.log('Option 3 clicked')}>
          Option 3
        </Dropdown.Item>
      </Dropdown.Menu>
    </Dropdown>
  );
}
```

---

## 6. Control Props Pattern

Control Props Pattern adalah teknik dimana komponen dapat dikontrol sepenuhnya oleh parent component tetapi juga bisa berfungsi secara independen (uncontrolled).

### Keuntungan Control Props Pattern:

- **Flexibility**: Memberikan opsi untuk mengontrol state dari luar
- **Integration**: Memudahkan integrasi dengan form libraries
- **Uncontrolled Fallback**: Berfungsi dengan baik bahkan tanpa eksternal state

### Contoh Basic Control Props:

```jsx
import React, { useState } from 'react';

function Counter({ count: controlledCount, onChange }) {
  // Internal state untuk uncontrolled mode
  const [internalCount, setInternalCount] = useState(0);
  
  // Cek apakah komponen controlled atau uncontrolled
  const isControlled = controlledCount !== undefined;
  const count = isControlled ? controlledCount : internalCount;
  
  const handleIncrement = () => {
    if (isControlled) {
      // Jika controlled, panggil callback
      onChange?.(count + 1);
    } else {
      // Jika uncontrolled, update internal state
      setInternalCount(internalCount + 1);
    }
  };
  
  return (
    <div>
      <p>Count: {count}</p>
      <button onClick={handleIncrement}>Increment</button>
    </div>
  );
}

// Penggunaan sebagai Controlled Component
function ControlledExample() {
  const [count, setCount] = useState(0);
  
  return (
    <div>
      <h2>Controlled Counter:</h2>
      <Counter count={count} onChange={setCount} />
      <button onClick={() => setCount(0)}>Reset</button>
    </div>
  );
}

// Penggunaan sebagai Uncontrolled Component
function UncontrolledExample() {
  return (
    <div>
      <h2>Uncontrolled Counter:</h2>
      <Counter />
    </div>
  );
}
```

### Switch/Toggle Component dengan Control Props:

```jsx
import React, { useState } from 'react';

function Toggle({ checked: controlledChecked, onChange, defaultChecked = false }) {
  // Internal state untuk uncontrolled mode
  const [internalChecked, setInternalChecked] = useState(defaultChecked);
  
  // Cek apakah controlled atau uncontrolled
  const isControlled = controlledChecked !== undefined;
  const checked = isControlled ? controlledChecked : internalChecked;
  
  const handleChange = () => {
    if (isControlled) {
      // Jika controlled, panggil callback
      onChange?.(!checked);
    } else {
      // Jika uncontrolled, update internal state
      setInternalChecked(!internalChecked);
    }
  };
  
  return (
    <label className="toggle">
      <input
        type="checkbox"
        checked={checked}
        onChange={handleChange}
      />
      <span className="slider" />
    </label>
  );
}

// Penggunaan sebagai Controlled Component
function ControlledExample() {
  const [checked, setChecked] = useState(false);
  
  return (
    <div>
      <h2>Controlled Toggle:</h2>
      <Toggle checked={checked} onChange={setChecked} />
      <p>Status: {checked ? 'ON' : 'OFF'}</p>
      <button onClick={() => setChecked(!checked)}>
        Toggle from outside
      </button>
    </div>
  );
}

// Penggunaan sebagai Uncontrolled Component
function UncontrolledExample() {
  return (
    <div>
      <h2>Uncontrolled Toggle:</h2>
      <Toggle defaultChecked={true} />
    </div>
  );
}
```

---

## 7. Project: Library of Reusable Components

Untuk mengaplikasikan semua pattern yang telah dipelajari, Anda akan membuat library komponen React yang dapat digunakan kembali.

### Tujuan Project:

- Menerapkan semua pattern yang telah dipelajari
- Membuat komponen yang reusable, maintainable, dan extensible
- Membangun dokumentasi dan contoh penggunaan

### Komponen yang Akan Dibuat:

1. **Button Component**
   - Berbagai variant (primary, secondary, danger)
   - Berbagai ukuran
   - Support untuk icons

2. **Form Components**
   - Input dengan validasi
   - Select
   - Checkbox
   - Radio button
   - Form group

3. **Modal/Dialog**
   - Menggunakan compound components pattern
   - Support untuk berbagai ukuran dan animasi

4. **Tabs Component**
   - Menggunakan compound components pattern
   - Support untuk berbagai styles

5. **Dropdown Menu**
   - Menggunakan compound components pattern
   - Support untuk nested menus

6. **Pagination**
   - Menggunakan control props pattern
   - Customizable appearance

### Langkah-langkah Project:

1. **Setup Project**
   - Inisialisasi project React
   - Setup development environment
   - Setup testing library

2. **Desain Komponen**
   - Tentukan API dan perilaku komponen
   - Buat prototype UI

3. **Implementasi**
   - Bangun komponen menggunakan pattern yang tepat
   - Tulis unit tests untuk setiap komponen

4. **Dokumentasi**
   - Buat dokumentasi penggunaan
   - Buat contoh implementasi

5. **Publikasi**
   - Publish ke npm (opsional)
   - Share code di GitHub

### Tips Implementasi:

- Gunakan hooks yang tepat untuk setiap use case
- Pertimbangkan aksesibilitas (a11y) untuk setiap komponen
- Pastikan komponen berfungsi dengan baik di berbagai browser
- Pertimbangkan dukungan untuk server-side rendering

---

## Kesimpulan

Setelah menyelesaikan modul ini, Anda telah mempelajari beberapa pattern dan teknik lanjutan dalam pengembangan React:

1. **Advanced Hooks**: useCallback, useMemo, dan useRef untuk mengoptimalkan performa dan menangani side-effects
2. **Custom Hooks**: Untuk mengekstrak dan menggunakan kembali logika komponen
3. **Higher-Order Components**: Untuk meningkatkan komponen dengan fungsionalitas tambahan
4. **Render Props Pattern**: Untuk berbagi logika antar komponen dengan fleksibilitas
5. **Compound Components**: Untuk membuat API komponen yang intuitif dan fleksibel
6. **Control Props Pattern**: Untuk mengelola state komponen dengan fleksibilitas

Pattern-pattern ini akan membantu Anda membangun aplikasi React yang lebih maintainable, reusable, dan scalable. Dengan menguasai pattern ini, Anda dapat membuat komponen-komponen yang kompleks namun tetap mudah digunakan dan dikembangkan.

---

## Referensi Tambahan

- [React Hooks Documentation](https://reactjs.org/docs/hooks-intro.html)
- [React Patterns](https://reactpatterns.com/)
- [Advanced React Patterns](https://kentcdodds.com/blog/advanced-react-patterns)
- [React Hooks Cookbook](https://usehooks.com/)
- [Building a Design System with React](https://www.learnstorybook.com/design-systems-for-developers/)

# MODUL 8: PERFORMANCE OPTIMIZATION REACT

## Daftar Isi
- [Pendahuluan](#pendahuluan)
- [Minggu 1: Dasar-dasar Optimasi React](#minggu-1-dasar-dasar-optimasi-react)
  - [React Profiler & Chrome DevTools](#react-profiler--chrome-devtools)
  - [Code Splitting & Lazy Loading](#code-splitting--lazy-loading)
  - [React.memo dan PureComponent](#reactmemo-dan-purecomponent)
- [Minggu 2: Teknik Optimasi Lanjutan](#minggu-2-teknik-optimasi-lanjutan)
  - [Virtualization dengan React Window](#virtualization-dengan-react-window)
  - [Web Vitals Optimization](#web-vitals-optimization)
  - [Bundle Analysis dan Optimization](#bundle-analysis-dan-optimization)
- [Project: Optimasi Aplikasi React](#project-optimasi-aplikasi-react)
- [Referensi dan Sumber Belajar Tambahan](#referensi-dan-sumber-belajar-tambahan)

## Pendahuluan

Performance Optimization (optimasi performa) adalah proses meningkatkan kecepatan, responsifitas, dan efisiensi aplikasi React. Sebagai developer, penting untuk memastikan aplikasi kita tidak hanya berfungsi dengan benar tetapi juga berjalan dengan cepat dan efisien.

Mengapa optimasi performa penting?
- Pengalaman pengguna yang lebih baik
- Mengurangi bounce rate (tingkat pentalan) pengunjung
- Meningkatkan SEO (Search Engine Optimization)
- Mengurangi biaya hosting dan bandwidth
- Aplikasi yang lebih hemat daya baterai pada perangkat mobile

Dalam modul ini, kita akan mempelajari berbagai teknik untuk mengoptimalkan aplikasi React, mulai dari mengidentifikasi masalah performa hingga menerapkan solusi yang tepat.

## Minggu 1: Dasar-dasar Optimasi React

### React Profiler & Chrome DevTools

#### Apa itu React Profiler?

React Profiler adalah fitur bawaan React Developer Tools yang memungkinkan kita untuk mengukur seberapa sering aplikasi React melakukan rendering dan "biaya" (waktu) yang dibutuhkan untuk rendering.

#### Cara Menggunakan React Profiler:

1. **Instal React Developer Tools**
   
   React Developer Tools adalah ekstensi browser yang tersedia untuk Chrome dan Firefox.

   ```bash
   # Atau install melalui toko ekstensi browser
   ```

2. **Mengakses React Profiler**
   
   Setelah menginstal, buka DevTools browser (F12 atau klik kanan -> Inspect) dan pilih tab "Profiler".

3. **Merekam Performa**
   
   - Klik tombol "Record" (lingkaran merah)
   - Lakukan interaksi dengan aplikasi
   - Klik "Stop" untuk menghentikan perekaman

4. **Menganalisis Hasil**
   
   Profiler akan menampilkan "commit" (pembaruan) yang dilakukan oleh React. Untuk setiap commit, Anda dapat melihat:
   - Waktu yang dibutuhkan
   - Flame chart (diagram yang menunjukkan waktu rendering setiap komponen)
   - Ranked chart (komponen yang diurutkan berdasarkan waktu rendering)
   - Component chart (menampilkan berapa kali komponen di-render)

#### Chrome DevTools untuk React

Chrome DevTools memiliki beberapa fitur yang berguna untuk mengoptimasi aplikasi React:

1. **Performance Tab**
   
   Memungkinkan analisis mendalam terhadap performa halaman web, termasuk:
   - Waktu loading
   - JavaScript execution time
   - Layout dan render time
   - Memory usage

2. **Lighthouse**
   
   Alat audit dalam Chrome DevTools yang memberikan skor dan rekomendasi untuk:
   - Performance
   - Accessibility
   - Best Practices
   - SEO
   - Progressive Web App

3. **Memory Tab**
   
   Membantu mendeteksi memory leaks dengan:
   - Heap Snapshot (menganalisis memory usage saat ini)
   - Allocation Instrumentation (melacak alokasi objek JavaScript)

#### Contoh Penggunaan Performance Tab

```javascript
// Contoh kode yang bisa dianalisis
function SlowComponent() {
  // Lakukan operasi yang berat
  const startTime = performance.now();
  while (performance.now() - startTime < 100) {
    // Block thread selama 100ms (simulasi operasi berat)
  }
  
  return <div>Komponen yang lambat</div>;
}
```

Langkah analisis:
1. Buka Chrome DevTools -> Performance tab
2. Klik "Record"
3. Render komponen SlowComponent
4. Stop recording
5. Analisis hasilnya untuk melihat berapa lama JavaScript berjalan

### Code Splitting & Lazy Loading

#### Apa itu Code Splitting?

Code Splitting adalah teknik untuk memecah bundle JavaScript menjadi beberapa file yang lebih kecil, sehingga browser hanya perlu memuat kode yang dibutuhkan pada saat itu. Ini sangat membantu untuk aplikasi besar dengan banyak halaman.

#### Implementasi Code Splitting dengan React.lazy dan Suspense

React.lazy dan Suspense memungkinkan kita untuk melakukan code splitting dengan mudah:

```javascript
// Sebelum code splitting
import BigComponent from './BigComponent';

// Setelah code splitting
import React, { Suspense, lazy } from 'react';
const BigComponent = lazy(() => import('./BigComponent'));

function App() {
  return (
    <div>
      <Suspense fallback={<div>Loading...</div>}>
        <BigComponent />
      </Suspense>
    </div>
  );
}
```

#### Lazy Loading untuk Routes

Contoh penggunaan dengan React Router:

```javascript
import React, { Suspense, lazy } from 'react';
import { BrowserRouter as Router, Routes, Route } from 'react-router-dom';

// Lazy load komponen halaman
const Home = lazy(() => import('./routes/Home'));
const About = lazy(() => import('./routes/About'));
const Dashboard = lazy(() => import('./routes/Dashboard'));

function App() {
  return (
    <Router>
      <Suspense fallback={<div>Loading...</div>}>
        <Routes>
          <Route path="/" element={<Home />} />
          <Route path="/about" element={<About />} />
          <Route path="/dashboard" element={<Dashboard />} />
        </Routes>
      </Suspense>
    </Router>
  );
}
```

#### Dynamic Import untuk Komponen Besar

```javascript
import React, { useState } from 'react';

function App() {
  const [showChart, setShowChart] = useState(false);
  const [ChartComponent, setChartComponent] = useState(null);
  
  const loadChart = async () => {
    // Hanya muat komponen chart ketika dibutuhkan
    const module = await import('./HeavyChartComponent');
    setChartComponent(() => module.default);
    setShowChart(true);
  };
  
  return (
    <div>
      <button onClick={loadChart}>Tampilkan Chart</button>
      {showChart && ChartComponent && <ChartComponent />}
    </div>
  );
}
```

### React.memo dan PureComponent

#### Apa itu Rendering yang Tidak Perlu?

React akan me-render ulang komponen ketika:
- Props berubah
- State berubah
- Parent component di-render ulang

Namun, jika props dan state tidak berubah, seringkali tidak perlu me-render ulang komponen.

#### React.memo untuk Function Components

React.memo adalah higher-order component (HOC) yang memungkinkan kita untuk "memoize" komponen fungsi. Ini berarti React akan melewati proses rendering jika props tidak berubah.

```javascript
import React from 'react';

// Tanpa React.memo
function ExpensiveComponent(props) {
  console.log('Rendering ExpensiveComponent');
  // Komponen dengan kalkulasi yang berat
  return <div>{props.value}</div>;
}

// Dengan React.memo
const MemoizedExpensiveComponent = React.memo(function ExpensiveComponent(props) {
  console.log('Rendering ExpensiveComponent');
  // Komponen dengan kalkulasi yang berat
  return <div>{props.value}</div>;
});

// Penggunaan
function App() {
  const [count, setCount] = useState(0);
  return (
    <div>
      <button onClick={() => setCount(count + 1)}>Increment</button>
      <div>Count: {count}</div>
      {/* Akan selalu di-render ulang ketika count berubah */}
      <ExpensiveComponent value={42} />
      {/* Hanya di-render ulang jika value berubah */}
      <MemoizedExpensiveComponent value={42} />
    </div>
  );
}
```

#### PureComponent untuk Class Components

Untuk class components, kita dapat menggunakan PureComponent yang secara otomatis mengimplementasikan shouldComponentUpdate dengan shallow comparison terhadap props dan state.

```javascript
import React, { Component, PureComponent } from 'react';

// Regular Component
class RegularComponent extends Component {
  render() {
    console.log('Rendering RegularComponent');
    return <div>{this.props.value}</div>;
  }
}

// Pure Component
class OptimizedComponent extends PureComponent {
  render() {
    console.log('Rendering OptimizedComponent');
    return <div>{this.props.value}</div>;
  }
}
```

#### Custom Comparison dengan React.memo

Jika kita membutuhkan logika perbandingan yang lebih kompleks, kita bisa memberikan fungsi comparison custom ke React.memo:

```javascript
const MemoizedComponent = React.memo(
  function MyComponent(props) {
    /* render menggunakan props */
    return <div>{props.value}</div>;
  },
  (prevProps, nextProps) => {
    // Return true jika ingin mencegah re-render
    // Return false jika ingin memperbolehkan re-render
    
    // Contoh: hanya re-render jika nilai berubah lebih dari 5
    return Math.abs(prevProps.value - nextProps.value) <= 5;
  }
);
```

#### Memoizing Expensive Calculations dengan useMemo

Untuk kalkulasi yang berat, gunakan useMemo:

```javascript
import React, { useState, useMemo } from 'react';

function ExpensiveCalculation({ number }) {
  // Tanpa useMemo (akan dihitung ulang setiap render)
  const expensiveResult = calculateExpensiveValue(number);
  
  // Dengan useMemo (hanya dihitung ulang jika number berubah)
  const memoizedResult = useMemo(() => {
    return calculateExpensiveValue(number);
  }, [number]);
  
  return <div>Result: {memoizedResult}</div>;
}

function calculateExpensiveValue(number) {
  console.log('Calculating...');
  // Simulasi kalkulasi yang berat
  let result = 0;
  for (let i = 0; i < 1000000; i++) {
    result += number;
  }
  return result;
}
```

#### useCallback untuk Memoizing Functions

Untuk memoizing functions, gunakan useCallback:

```javascript
import React, { useState, useCallback } from 'react';

function ParentComponent() {
  const [count, setCount] = useState(0);
  
  // Tanpa useCallback (fungsi baru akan dibuat setiap render)
  const handleClick = () => {
    console.log('Clicked!');
  };
  
  // Dengan useCallback (fungsi yang sama akan digunakan kembali)
  const memoizedHandleClick = useCallback(() => {
    console.log('Clicked!');
  }, []); // Array dependency kosong berarti fungsi ini tidak akan pernah dibuat ulang
  
  return (
    <div>
      <button onClick={() => setCount(count + 1)}>Count: {count}</button>
      {/* Child akan selalu re-render karena handleClick selalu baru */}
      <ChildComponent onClick={handleClick} />
      {/* Child hanya re-render jika memoizedHandleClick berubah */}
      <MemoizedChildComponent onClick={memoizedHandleClick} />
    </div>
  );
}

const ChildComponent = React.memo(function ChildComponent(props) {
  console.log('Child rendering');
  return <button onClick={props.onClick}>Click me</button>;
});
```

## Minggu 2: Teknik Optimasi Lanjutan

### Virtualization dengan React Window

#### Apa itu Virtualization?

Virtualization adalah teknik untuk merender hanya item yang terlihat pada viewport, bukan seluruh daftar panjang. Ini sangat berguna untuk daftar dengan ribuan item.

#### Menggunakan React Window

React Window adalah library populer untuk virtualisasi di React.

Instalasi:
```bash
npm install react-window
# atau
yarn add react-window
```

Contoh penggunaan dasar:

```javascript
import React from 'react';
import { FixedSizeList as List } from 'react-window';

const ITEM_HEIGHT = 35; // Tinggi setiap item dalam pixel

function Row({ index, style }) {
  return (
    <div style={style}>
      Item {index}
    </div>
  );
}

function ExampleList({ items }) {
  return (
    <List
      height={400} // Tinggi viewport
      width={300} // Lebar list
      itemCount={items.length} // Jumlah total item
      itemSize={ITEM_HEIGHT} // Tinggi setiap item
    >
      {Row}
    </List>
  );
}

// Penggunaan:
function App() {
  // Simulasi daftar dengan 10,000 item
  const items = Array.from({ length: 10000 }, (_, i) => ({ id: i, text: `Item ${i}` }));
  
  return <ExampleList items={items} />;
}
```

#### FixedSizeList vs VariableSizeList

React Window menyediakan dua jenis list utama:

1. **FixedSizeList**: Untuk list dengan item berukuran sama
   ```javascript
   import { FixedSizeList } from 'react-window';
   
   <FixedSizeList
     height={400}
     width={300}
     itemCount={1000}
     itemSize={35}
   >
     {Row}
   </FixedSizeList>
   ```

2. **VariableSizeList**: Untuk list dengan item berukuran bervariasi
   ```javascript
   import { VariableSizeList } from 'react-window';
   
   // Function untuk menentukan tinggi item berdasarkan index
   const getItemSize = index => {
     return index % 2 === 0 ? 30 : 50; // Item genap: 30px, ganjil: 50px
   };
   
   <VariableSizeList
     height={400}
     width={300}
     itemCount={1000}
     itemSize={getItemSize}
   >
     {Row}
   </VariableSizeList>
   ```

#### Menggunakan dengan Data Kompleks

```javascript
import React from 'react';
import { FixedSizeList } from 'react-window';

// Data contoh
const users = Array.from({ length: 5000 }, (_, index) => ({
  id: index,
  name: `User ${index}`,
  email: `user${index}@example.com`,
  avatar: `https://randomuser.me/api/portraits/men/${index % 100}.jpg`
}));

// Komponen untuk setiap baris
function UserRow({ index, style }) {
  const user = users[index];
  
  return (
    <div style={{
      ...style,
      display: 'flex',
      alignItems: 'center',
      padding: '10px',
      borderBottom: '1px solid #eee'
    }}>
      <img 
        src={user.avatar} 
        alt={user.name}
        style={{ width: 40, height: 40, borderRadius: '50%', marginRight: 10 }}
      />
      <div>
        <div style={{ fontWeight: 'bold' }}>{user.name}</div>
        <div style={{ fontSize: '0.8em', color: '#666' }}>{user.email}</div>
      </div>
    </div>
  );
}

// Komponen list
function UserList() {
  return (
    <FixedSizeList
      height={500}
      width={400}
      itemCount={users.length}
      itemSize={60} // Tinggi setiap baris
    >
      {UserRow}
    </FixedSizeList>
  );
}
```

#### Infinite Loading dengan React Window

Menambahkan infinite loading:

```javascript
import React, { useState, useEffect } from 'react';
import { FixedSizeList } from 'react-window';
import InfiniteLoader from 'react-window-infinite-loader';

function InfiniteUserList() {
  const [users, setUsers] = useState([]);
  const [hasNextPage, setHasNextPage] = useState(true);
  const [isNextPageLoading, setIsNextPageLoading] = useState(false);
  
  // Simulasi loading data dari API
  const loadMoreItems = async (startIndex, stopIndex) => {
    setIsNextPageLoading(true);
    
    // Simulasi network request
    await new Promise(resolve => setTimeout(resolve, 1000));
    
    const newUsers = Array.from({ length: stopIndex - startIndex + 1 }, (_, i) => ({
      id: startIndex + i,
      name: `User ${startIndex + i}`,
      email: `user${startIndex + i}@example.com`
    }));
    
    setUsers(prevUsers => [...prevUsers, ...newUsers]);
    setIsNextPageLoading(false);
    
    // Simulasi akhir data setelah 500 item
    if (stopIndex >= 500) {
      setHasNextPage(false);
    }
  };
  
  // Item status: apakah sudah dimuat atau belum
  const isItemLoaded = index => index < users.length;
  
  // Render setiap item
  const Item = ({ index, style }) => {
    if (!isItemLoaded(index)) {
      return <div style={style}>Loading...</div>;
    }
    
    const user = users[index];
    return (
      <div style={style}>
        <div>{user.name}</div>
        <div>{user.email}</div>
      </div>
    );
  };
  
  return (
    <InfiniteLoader
      isItemLoaded={isItemLoaded}
      itemCount={hasNextPage ? users.length + 1 : users.length}
      loadMoreItems={loadMoreItems}
    >
      {({ onItemsRendered, ref }) => (
        <FixedSizeList
          height={400}
          width={300}
          itemCount={hasNextPage ? users.length + 1 : users.length}
          itemSize={50}
          onItemsRendered={onItemsRendered}
          ref={ref}
        >
          {Item}
        </FixedSizeList>
      )}
    </InfiniteLoader>
  );
}
```

### Web Vitals Optimization

#### Apa itu Web Vitals?

Web Vitals adalah inisiatif Google untuk menyediakan panduan terpadu tentang sinyal kualitas penting yang diperlukan untuk memberikan pengalaman pengguna yang baik di web.

#### Core Web Vitals

Ada tiga Core Web Vitals yang menjadi fokus utama:

1. **Largest Contentful Paint (LCP)**: Kecepatan loading
   - Mengukur waktu yang dibutuhkan untuk memuat konten terbesar yang terlihat
   - Target: < 2.5 detik

2. **First Input Delay (FID)**: Interaktivitas
   - Mengukur waktu dari interaksi pertama pengguna hingga browser dapat merespon
   - Target: < 100 ms

3. **Cumulative Layout Shift (CLS)**: Stabilitas visual
   - Mengukur seberapa banyak elemen halaman bergeser secara tidak terduga
   - Target: < 0.1

#### Mengukur Web Vitals

Kita dapat mengukur Web Vitals menggunakan:

1. **Lighthouse** (dalam Chrome DevTools)
2. **PageSpeed Insights**: https://pagespeed.web.dev/
3. **web-vitals library**

```bash
npm install web-vitals
# atau
yarn add web-vitals
```

```javascript
import { getCLS, getFID, getLCP } from 'web-vitals';

function sendToAnalytics(metric) {
  // Kirim data ke analytics
  console.log(metric);
}

getCLS(sendToAnalytics);
getFID(sendToAnalytics);
getLCP(sendToAnalytics);
```

#### Optimasi Largest Contentful Paint (LCP)

1. **Optimalkan Server Response Time**
   - Gunakan CDN
   - Implementasi caching server-side
   - Optimalkan database queries

2. **Preload Resource Penting**
   ```html
   <link rel="preload" href="critical-image.jpg" as="image" />
   ```

3. **Optimalkan dan Compress Gambar**
   - Gunakan format modern (WebP)
   - Gunakan lazy loading untuk gambar di bawah fold

4. **Minimalkan CSS yang Blocking**
   - Ekstrak CSS kritikal dan inlinekan
   - Defer CSS non-kritikal

#### Optimasi First Input Delay (FID)

1. **Minimalkan JavaScript yang Tidak Diperlukan**
   - Code splitting
   - Tree shaking
   - Lazy loading

2. **Break Up Long Tasks**
   ```javascript
   // Sebelum: Task yang panjang
   function processData() {
     for (let i = 0; i < 10000; i++) {
       // Operasi berat
     }
   }
   
   // Sesudah: Dipecah menjadi chunk-chunk kecil
   function processDataInChunks(i = 0) {
     // Proses hanya 100 item per waktu
     let end = Math.min(i + 100, 10000);
     
     for (let j = i; j < end; j++) {
       // Operasi berat
     }
     
     if (end < 10000) {
       // Jadwalkan chunk berikutnya
       setTimeout(() => processDataInChunks(end), 0);
     }
   }
   ```

3. **Gunakan Web Workers untuk Tugas Berat**
   ```javascript
   // main.js
   const worker = new Worker('worker.js');
   
   // Kirim data ke worker
   worker.postMessage({ data: complexData });
   
   // Terima hasil dari worker
   worker.onmessage = function(e) {
     console.log('Result:', e.data.result);
   };
   
   // worker.js
   self.onmessage = function(e) {
     // Lakukan kalkulasi berat di sini
     const result = doHeavyCalculation(e.data.data);
     
     // Kirim hasil kembali ke thread utama
     self.postMessage({ result });
   };
   ```

#### Optimasi Cumulative Layout Shift (CLS)

1. **Selalu Tentukan Dimensi Gambar**
   ```html
   <!-- Buruk: Tidak ada dimensi -->
   <img src="image.jpg" alt="Description">
   
   <!-- Baik: Ada dimensi -->
   <img src="image.jpg" width="640" height="360" alt="Description">
   ```

2. **Hindari Memasukkan Konten Dinamis di Atas Konten yang Sudah Ada**
   - Gunakan placeholder dengan ukuran yang tepat
   - Alokasikan space untuk iklan dan embeds

3. **Gunakan CSS transform untuk Animasi**
   ```css
   /* Buruk: Mengubah layout */
   .box:hover {
     margin-top: 20px;
   }
   
   /* Baik: Menggunakan transform */
   .box:hover {
     transform: translateY(20px);
   }
   ```

### Bundle Analysis dan Optimization

#### Menganalisis Bundle Size

Sebelum mengoptimasi bundle, kita perlu mengetahui apa yang menyebabkan bundle besar.

1. **webpack-bundle-analyzer**
   ```bash
   npm install --save-dev webpack-bundle-analyzer
   # atau
   yarn add --dev webpack-bundle-analyzer
   ```

   Konfigurasi untuk create-react-app:
   ```javascript
   // Buat file craco.config.js
   const BundleAnalyzerPlugin = require('webpack-bundle-analyzer').BundleAnalyzerPlugin;

   module.exports = {
     webpack: {
       plugins: {
         add: [
           new BundleAnalyzerPlugin({
             analyzerMode: 'server',
           }),
         ],
       },
     },
   };
   ```

2. **source-map-explorer**
   ```bash
   npm install --save-dev source-map-explorer
   # atau
   yarn add --dev source-map-explorer
   
   # Tambahkan script ke package.json
   "scripts": {
     "analyze": "source-map-explorer 'build/static/js/*.js'"
   }
   ```

#### Strategi Optimasi Bundle

1. **Mengurangi Ukuran Dependencies**
   - Gunakan [bundlephobia.com](https://bundlephobia.com/) untuk mencari alternativ package yang lebih kecil
   - Contoh: moment.js (329kB) vs date-fns (13kB) atau dayjs (2kB)

2. **Tree Shaking**
   
   Tree shaking adalah proses menghilangkan kode yang tidak digunakan dari bundle.

   ```javascript
   // Sebelum: Import seluruh lodash
   import _ from 'lodash';
   
   // Sesudah: Import hanya yang dibutuhkan
   import { debounce } from 'lodash-es';
   
   // Atau lebih baik lagi
   import debounce from 'lodash/debounce';
   ```

3. **Dynamic Imports**
   
   Selain untuk code splitting, dynamic imports juga mengurangi ukuran bundle awal.

   ```javascript
   // Sebelum
   import Chart from 'chart.js';
   
   function Dashboard() {
     return (
       <div>
         <h1>Dashboard</h1>
         <Chart data={...} />
       </div>
     );
   }
   
   // Sesudah
   function Dashboard() {
     const [Chart, setChart] = useState(null);
     
     useEffect(() => {
       import('chart.js').then(module => {
         setChart(() => module.default);
       });
     }, []);
     
     return (
       <div>
         <h1>Dashboard</h1>
         {Chart && <Chart data={...} />}
       </div>
     );
   }
   ```

4. **Optimasi Gambar dan Assets**
   - Compress gambar
   - Gunakan WebP untuk gambar
   - Sprite sheets untuk ikon
   - Minifikasi CSS dan JavaScript

5. **Mengurangi Polyfills**
   
   Jika tidak perlu mendukung browser lama, kurangi polyfills:

   ```javascript
   // Buat file .browserslistrc
   
   // Sebelum (mendukung banyak browser lama)
   > 0.5%
   last 2 versions
   Firefox ESR
   not dead
   
   // Sesudah (hanya browser modern)
   last 2 Chrome versions
   last 2 Firefox versions
   last 2 Edge versions
   last 2 Safari versions
   ```

6. **Menggunakan CDN untuk Libraries Besar**
   
   Untuk library besar, gunakan CDN dan externals:

   ```html
   <!-- Tambahkan di index.html -->
   <script src="https://unpkg.com/react@17/umd/react.production.min.js" crossorigin></script>
   <script src="https://unpkg.com/react-dom@17/umd/react-dom.production.min.js" crossorigin></script>
   ```

   ```javascript
   // Konfigurasi webpack
   module.exports = {
     //...
     externals: {
       'react': 'React',
       'react-dom': 'ReactDOM'
     }
   };
   ```

## Project: Optimasi Aplikasi React

### Tujuan Project

1. Mengidentifikasi dan memperbaiki masalah performa pada aplikasi React yang sudah ada
2. Menerapkan teknik optimasi yang telah dipelajari
3. Mengukur dampak optimasi yang dilakukan

### Langkah-langkah Project

#### 1. Analisis Awal

1. **Audit dengan Lighthouse**
   - Jalankan audit Lighthouse
   - Catat skor awal (Performance, Accessibility, Best Practices, SEO)
   - Identifikasi kesempatan perbaikan

2. **Profiling dengan React Profiler**
   - Identifikasi komponen yang sering di-render ulang
   - Catat waktu rendering setiap komponen
   - Identifikasi komponen yang membutuhkan waktu rendering lama

3. **Analisis Bundle Size**
   - Gunakan webpack-bundle-analyzer atau source-map-explorer
   - Identifikasi package/dependencies yang besar
   - Identifikasi code yang bisa di-split atau lazy load

#### 2. Implementasi Optimasi

1. **Optimasi Rendering**
   - Terapkan React.memo atau PureComponent untuk komponen yang sering di-render
   - Gunakan useMemo untuk kalkulasi berat
   - Gunakan useCallback untuk memoizing functions

2. **Code Splitting dan Lazy Loading**
   - Identifikasi bagian aplikasi yang bisa di-lazy load
   - Implementasikan React.lazy dan Suspense
   - Gunakan dynamic imports untuk komponen besar

3. **Virtualisasi untuk Daftar Panjang**
   - Implementasikan React Window untuk daftar dengan banyak item
   - Optimalkan rendering list yang kompleks

4. **Optimasi Bundle Size**
   - Kurangi size dependencies dengan alternative yang lebih kecil
   - Implementasikan tree shaking
   - Hapus dependencies yang tidak digunakan
   - Minifikasi assets (gambar, fonts, dll)

5. **Optimasi Web Vitals**
   - Perbaiki Largest Contentful Paint (LCP)
   - Tingkatkan First Input Delay (FID)
   - Minimalkan Cumulative Layout Shift (CLS)

#### 3. Pengukuran Hasil

1. **Ukur Ulang dengan Lighthouse**
   - Bandingkan skor sebelum dan sesudah optimasi
   - Dokumentasikan peningkatan

2. **Profiling Ulang dengan React Profiler**
   - Bandingkan waktu rendering sebelum dan sesudah optimasi
   - Catat komponen yang berhasil dioptimasi

3. **Analisis Bundle Size Ulang**
   - Bandingkan ukuran bundle sebelum dan sesudah optimasi
   - Dokumentasikan pengurangan ukuran

### Contoh Implementasi Project

Berikut adalah contoh kerangka implementasi untuk project optimasi aplikasi React:

#### 1. Identifikasi Masalah

```javascript
// Contoh komponen yang tidak optimal
function UserList({ users }) {
  // Tidak menggunakan virtualisasi
  return (
    <div>
      {users.map(user => (
        <UserCard key={user.id} user={user} />
      ))}
    </div>
  );
}

// Komponen yang di-render ulang meskipun props tidak berubah
function UserCard({ user }) {
  // Tidak menggunakan memoization
  return (
    <div className="user-card">
      <img src={user.avatar} alt={user.name} />
      <h3>{user.name}</h3>
      <p>{user.email}</p>
    </div>
  );
}
```

#### 2. Solusi Optimasi

```javascript
import React, { useMemo } from 'react';
import { FixedSizeList } from 'react-window';

// Optimasi dengan virtualisasi
function OptimizedUserList({ users }) {
  const Row = ({ index, style }) => {
    const user = users[index];
    return <MemoizedUserCard style={style} user={user} />;
  };

  return (
    <FixedSizeList
      height={500}
      width="100%"
      itemCount={users.length}
      itemSize={80}
    >
      {Row}
    </FixedSizeList>
  );
}

// Optimasi dengan memoization
const MemoizedUserCard = React.memo(function UserCard({ user, style }) {
  return (
    <div className="user-card" style={style}>
      <img src={user.avatar} alt={user.name} />
      <h3>{user.name}</h3>
      <p>{user.email}</p>
    </div>
  );
});

// Optimasi dengan useMemo untuk heavy calculations
function UserStats({ users }) {
  // Kalkulasi statistik yang berat
  const stats = useMemo(() => {
    console.log('Calculating stats...');
    return {
      totalUsers: users.length,
      activeUsers: users.filter(u => u.isActive).length,
      averageAge: users.reduce((acc, u) => acc + u.age, 0) / users.length
    };
  }, [users]); // Hanya hitung ulang jika users berubah

  return (
    <div className="stats">
      <div>Total Users: {stats.totalUsers}</div>
      <div>Active Users: {stats.activeUsers}</div>
      <div>Average Age: {stats.averageAge.toFixed(1)}</div>
    </div>
  );
}
```

#### 3. Implementasi Code Splitting

```javascript
// App.js sebelum
import React from 'react';
import { BrowserRouter, Routes, Route } from 'react-router-dom';
import Home from './pages/Home';
import Dashboard from './pages/Dashboard';
import Analytics from './pages/Analytics';
import Settings from './pages/Settings';
import NotFound from './pages/NotFound';

function App() {
  return (
    <BrowserRouter>
      <Routes>
        <Route path="/" element={<Home />} />
        <Route path="/dashboard" element={<Dashboard />} />
        <Route path="/analytics" element={<Analytics />} />
        <Route path="/settings" element={<Settings />} />
        <Route path="*" element={<NotFound />} />
      </Routes>
    </BrowserRouter>
  );
}

// App.js sesudah dengan code splitting
import React, { Suspense, lazy } from 'react';
import { BrowserRouter, Routes, Route } from 'react-router-dom';

// Eager load homepage untuk pengalaman awal yang lebih baik
import Home from './pages/Home';

// Lazy load halaman lainnya
const Dashboard = lazy(() => import('./pages/Dashboard'));
const Analytics = lazy(() => import('./pages/Analytics'));
const Settings = lazy(() => import('./pages/Settings'));
const NotFound = lazy(() => import('./pages/NotFound'));

function App() {
  return (
    <BrowserRouter>
      <Suspense fallback={<div className="loading-spinner">Loading...</div>}>
        <Routes>
          <Route path="/" element={<Home />} />
          <Route path="/dashboard" element={<Dashboard />} />
          <Route path="/analytics" element={<Analytics />} />
          <Route path="/settings" element={<Settings />} />
          <Route path="*" element={<NotFound />} />
        </Routes>
      </Suspense>
    </BrowserRouter>
  );
}
```

## Referensi dan Sumber Belajar Tambahan

### Dokumentasi Resmi
- [React Documentation: Optimizing Performance](https://reactjs.org/docs/optimizing-performance.html)
- [React Developer Tools](https://reactjs.org/blog/2019/08/15/new-react-devtools.html)
- [React.memo](https://reactjs.org/docs/react-api.html#reactmemo)
- [Code Splitting in React](https://reactjs.org/docs/code-splitting.html)
- [Web Vitals](https://web.dev/vitals/)

### Library dan Tools
- [React Window](https://github.com/bvaughn/react-window)
- [webpack-bundle-analyzer](https://github.com/webpack-contrib/webpack-bundle-analyzer)
- [source-map-explorer](https://github.com/danvk/source-map-explorer)
- [Lighthouse](https://developers.google.com/web/tools/lighthouse)
- [web-vitals library](https://github.com/GoogleChrome/web-vitals)

### Artikel dan Tutorial
- [A Complete Guide to useCallback](https://dmitripavlutin.com/react-usecallback/)
- [When to useMemo and useCallback](https://kentcdodds.com/blog/usememo-and-usecallback)
- [React Performance Optimization](https://medium.com/@ariklevliber/react-performance-optimization-techniques-in-2023-46a574f0d12a)
- [Understanding Tree Shaking](https://developers.google.com/web/fundamentals/performance/optimizing-javascript/tree-shaking)
- [The Ultimate Guide to Web Performance](https://developers.google.com/web/fundamentals/performance/get-started)

### Video Courses
- [Frontend Masters: React Performance](https://frontendmasters.com/courses/react-performance/)
- [Egghead.io: Optimize React Apps](https://egghead.io/courses/optimize-react-apps)
- [Pluralsight: React Performance Playbook](https://www.pluralsight.com/courses/react-performance-playbook)

---

Semoga modul ini membantu Anda memahami dan mengimplementasikan teknik-teknik optimasi performa pada aplikasi React. Ingat bahwa optimasi performa sebaiknya dilakukan setelah aplikasi berfungsi dengan benar, dan sebaiknya fokus pada perbaikan yang paling berdampak terlebih dahulu. Happy coding!
